<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pi-Guy Voice Agent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --blue: #0088ff;
            --blue-dim: #0055aa;
            --blue-bright: #00aaff;
            --cyan: #00ffff;
            --green: #00ff66;
            --yellow: #ffdd00;
            --orange: #ff6600;
            --red: #ff2244;
            --dark-bg: #050508;
            --panel-bg: #0a0a12;
        }

        body {
            background: var(--dark-bg);
            font-family: 'Courier New', monospace;
            color: var(--blue);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Animated background grid */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(0,136,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,136,255,0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: -1;
        }

        /* Main face area */
        .face-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        /* Eyes container */
        .eyes-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            margin-bottom: 50px;
            position: relative;
            z-index: 1;
        }

        .eye {
            position: relative;
            width: 120px;
            height: 140px;
        }

        .eye-white {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #ffffff 0%, #e8e8e8 70%, #cccccc 100%);
            border-radius: 50% 50% 45% 45%;
            box-shadow:
                0 0 30px rgba(0, 136, 255, 0.3),
                inset 0 -10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .pupil-container {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s ease-out;
        }

        .pupil {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at 30% 30%, #333 0%, #000 70%);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .pupil::before {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 8px;
            left: 8px;
        }

        .pupil::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            top: 20px;
            right: 12px;
        }

        /* Eyelids */
        .eyelid-top {
            position: absolute;
            width: 130%;
            height: 75%;
            background: var(--dark-bg);
            top: -60%;
            left: -15%;
            border-radius: 0 0 50% 50%;
            transition: transform 0.15s ease-in-out;
            z-index: 10;
        }

        .eyelid-bottom {
            position: absolute;
            width: 130%;
            height: 40%;
            background: var(--dark-bg);
            bottom: -35%;
            left: -15%;
            border-radius: 50% 50% 0 0;
            transition: transform 0.15s ease-in-out;
            z-index: 10;
        }

        /* Blink animation */
        .eye.blinking .eyelid-top {
            transform: translateY(90%);
        }

        .eye.blinking .eyelid-bottom {
            transform: translateY(-30%);
        }

        /* Mood: Angry */
        .eye.angry .eyelid-top {
            transform: translateY(40%) rotate(var(--angry-rotate, 0deg));
        }

        .left-eye.angry .eyelid-top {
            --angry-rotate: 15deg;
            transform-origin: right center;
        }

        .right-eye.angry .eyelid-top {
            --angry-rotate: -15deg;
            transform-origin: left center;
        }

        /* Mood: Sad */
        .eye.sad .eyelid-top {
            transform: translateY(30%) rotate(var(--sad-rotate, 0deg));
        }

        .left-eye.sad .eyelid-top {
            --sad-rotate: -10deg;
            transform-origin: left center;
        }

        .right-eye.sad .eyelid-top {
            --sad-rotate: 10deg;
            transform-origin: right center;
        }

        /* Mood: Happy */
        .eye.happy .eyelid-bottom {
            transform: translateY(-60%);
        }

        /* Mood: Thinking */
        .eye.thinking .pupil-container {
            transform: translate(15px, -15px) !important;
        }

        .left-eye.thinking .eyelid-top {
            transform: translateY(25%);
        }

        /* Mood: Surprised */
        .eye.surprised .eye-white {
            transform: scale(1.1);
        }

        .eye.surprised .pupil {
            transform: scale(0.8);
        }

        /* Mood: Listening */
        .eye.listening .pupil {
            animation: listening-pulse 1.5s ease-in-out infinite;
        }

        @keyframes listening-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Waveform mouth */
        .mouth-container {
            width: 200px;
            height: 60px;
            position: relative;
            z-index: 10;
        }

        #waveform-canvas {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 10px var(--cyan));
        }

        /* Status indicator */
        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--blue-dim);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--blue-dim);
            transition: background 0.3s;
        }

        .status-dot.connected {
            background: var(--green);
            animation: pulse-dot 2s ease-in-out infinite;
        }

        .status-dot.connecting {
            background: var(--yellow);
            animation: pulse-dot 0.5s ease-in-out infinite;
        }

        .status-dot.speaking {
            background: var(--cyan);
            animation: pulse-dot 0.3s ease-in-out infinite;
        }

        .status-dot.listening {
            background: var(--green);
            animation: pulse-dot 0.5s ease-in-out infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Mood label */
        .mood-label {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 0.8rem;
            color: var(--blue-dim);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Call button */
        .call-button {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid var(--green);
            background: var(--panel-bg);
            color: var(--green);
            font-size: 2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .call-button:hover {
            box-shadow: 0 0 30px rgba(0, 255, 102, 0.5);
            transform: translateX(-50%) scale(1.1);
        }

        .call-button.active {
            border-color: var(--red);
            color: var(--red);
            background: rgba(255, 34, 68, 0.2);
        }

        .call-button.active:hover {
            box-shadow: 0 0 30px rgba(255, 34, 68, 0.5);
        }

        .call-button.connecting {
            border-color: var(--yellow);
            color: var(--yellow);
            animation: connecting-pulse 1s ease-in-out infinite;
        }

        @keyframes connecting-pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 221, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 221, 0, 0.6); }
        }

        /* Wake word button */
        .wake-button {
            position: absolute;
            bottom: 40px;
            left: calc(50% - 120px);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--blue-dim);
            background: var(--panel-bg);
            color: var(--blue-dim);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .wake-button:hover {
            box-shadow: 0 0 20px rgba(0, 136, 255, 0.5);
            border-color: var(--blue);
        }

        .wake-button.active {
            border-color: var(--green);
            color: var(--green);
            box-shadow: 0 0 20px rgba(0, 255, 102, 0.4);
            animation: wake-pulse 2s ease-in-out infinite;
        }

        @keyframes wake-pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 255, 102, 0.3); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 102, 0.6); }
        }

        /* Camera button */
        .camera-button {
            position: absolute;
            bottom: 40px;
            left: calc(50% + 60px);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--blue-dim);
            background: var(--panel-bg);
            color: var(--blue-dim);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 100;
            overflow: hidden;
        }

        .camera-button:hover {
            box-shadow: 0 0 20px rgba(0, 136, 255, 0.5);
            border-color: var(--blue);
        }

        .camera-button.active {
            border-color: var(--cyan);
            color: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        .camera-button .camera-icon {
            position: absolute;
            z-index: 2;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            transition: opacity 0.3s;
        }

        .camera-button.active .camera-icon {
            opacity: 0.7;
            font-size: 1rem;
            top: 5px;
            right: 5px;
        }

        .camera-button video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .camera-button.active video {
            opacity: 1;
        }

        /* Transcription display */
        .transcription-display {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--blue-dim);
            border-radius: 8px;
            padding: 12px 20px;
            max-width: 85%;
            max-height: 150px;
            overflow-y: auto;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        .transcription-display #transcription-text {
            max-height: 100px;
            overflow-y: auto;
            padding-right: 10px;
        }

        /* Custom scrollbar for transcription */
        .transcription-display::-webkit-scrollbar,
        .transcription-display #transcription-text::-webkit-scrollbar {
            width: 6px;
        }

        .transcription-display::-webkit-scrollbar-track,
        .transcription-display #transcription-text::-webkit-scrollbar-track {
            background: rgba(0, 100, 150, 0.2);
            border-radius: 3px;
        }

        .transcription-display::-webkit-scrollbar-thumb,
        .transcription-display #transcription-text::-webkit-scrollbar-thumb {
            background: var(--blue-dim);
            border-radius: 3px;
        }

        .transcription-display::-webkit-scrollbar-thumb:hover,
        .transcription-display #transcription-text::-webkit-scrollbar-thumb:hover {
            background: var(--cyan);
        }

        .transcription-display.visible {
            opacity: 1;
        }

        .transcription-display .label {
            font-size: 0.7rem;
            color: var(--blue-dim);
            margin-bottom: 5px;
        }

        .transcription-display.user .label { color: var(--green); }
        .transcription-display.agent .label { color: var(--cyan); }

        /* Agent ID input modal */
        .setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .setup-modal.hidden {
            display: none;
        }

        .setup-box {
            background: var(--panel-bg);
            border: 1px solid var(--blue);
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            text-align: center;
        }

        .setup-box h2 {
            color: var(--cyan);
            margin-bottom: 20px;
        }

        .setup-box p {
            color: var(--blue-dim);
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .setup-box input {
            width: 100%;
            padding: 12px;
            background: var(--dark-bg);
            border: 1px solid var(--blue-dim);
            border-radius: 6px;
            color: var(--blue);
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .setup-box input:focus {
            outline: none;
            border-color: var(--cyan);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .setup-box button {
            padding: 12px 30px;
            background: var(--blue);
            border: none;
            border-radius: 6px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .setup-box button:hover {
            background: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        /* Error message */
        .error-message {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 34, 68, 0.2);
            border: 1px solid var(--red);
            border-radius: 8px;
            padding: 10px 20px;
            color: var(--red);
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 60;
        }

        .error-message.visible {
            opacity: 1;
        }

        /* Instructions */
        .instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #333;
            text-align: center;
        }

        /* Community Panel */
        .community-panel {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 900;
        }

        .community-toggle {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--blue);
            border-right: none;
            border-radius: 10px 0 0 10px;
            padding: 15px 8px;
            cursor: pointer;
            color: var(--blue);
            font-size: 1.2rem;
            transition: all 0.3s;
        }

        .community-toggle:hover {
            background: var(--blue);
            color: white;
        }

        .community-content {
            position: absolute;
            right: -320px;
            top: 50%;
            transform: translateY(-50%);
            width: 300px;
            max-height: 80vh;
            background: var(--panel-bg);
            border: 1px solid var(--blue);
            border-radius: 10px 0 0 10px;
            padding: 15px;
            transition: right 0.3s ease;
            overflow-y: auto;
        }

        .community-content.open {
            right: 0;
        }

        .community-content h3 {
            color: var(--cyan);
            margin-bottom: 15px;
            font-size: 1rem;
            border-bottom: 1px solid var(--blue-dim);
            padding-bottom: 10px;
        }

        .community-list {
            list-style: none;
            margin-bottom: 15px;
        }

        .community-list li {
            padding: 8px 10px;
            margin: 5px 0;
            background: rgba(0, 136, 255, 0.1);
            border-radius: 5px;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .community-list li .photo-count {
            font-size: 0.7rem;
            color: var(--blue-dim);
        }

        .face-register {
            border-top: 1px solid var(--blue-dim);
            padding-top: 15px;
            margin-top: 10px;
        }

        .face-register h4 {
            color: var(--green);
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .face-register input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: var(--dark-bg);
            border: 1px solid var(--blue-dim);
            border-radius: 5px;
            color: var(--blue);
            font-family: 'Courier New', monospace;
        }

        .face-register-buttons {
            display: flex;
            gap: 10px;
        }

        .face-register button {
            flex: 1;
            padding: 8px;
            background: var(--blue);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .face-register button:hover {
            background: var(--blue-bright);
        }

        .face-register button:disabled {
            background: var(--blue-dim);
            cursor: not-allowed;
        }

        .face-register .upload-btn {
            background: var(--green);
        }

        .face-register .upload-btn:hover {
            background: #00cc55;
        }

        .photo-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }

        .photo-preview img {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 5px;
            border: 1px solid var(--blue-dim);
        }

        .register-status {
            font-size: 0.75rem;
            color: var(--cyan);
            margin-top: 10px;
        }
    </style>
    <!-- Clerk Authentication -->
    <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="pk_test_c21hcnQtc25hcHBlci04LmNsZXJrLmFjY291bnRzLmRldiQ"
        src="https://cdn.jsdelivr.net/npm/@clerk/clerk-js@latest/dist/clerk.browser.js"
        type="text/javascript">
    </script>
</head>
<body>
    <!-- User Auth Section -->
    <div id="auth-section" style="position: fixed; top: 10px; right: 10px; z-index: 1000;">
        <div id="user-button"></div>
        <div id="sign-in-button" style="display: none;">
            <button id="login-btn" style="background: var(--blue); color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace;">Login</button>
        </div>
    </div>
    <!-- Login Modal -->
    <div id="clerk-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center;">
        <div id="sign-in-container" style="background: var(--panel-bg); padding: 20px; border-radius: 10px; border: 1px solid var(--blue);"></div>
    </div>

    <!-- Community Panel -->
    <div class="community-panel">
        <button class="community-toggle" id="community-toggle" title="Community Faces">üë•</button>
        <div class="community-content" id="community-content">
            <h3>üë• Community Faces</h3>
            <ul class="community-list" id="community-list">
                <!-- Populated by JS -->
            </ul>
            <div class="face-register">
                <h4>üì∏ Register Your Face</h4>
                <input type="text" id="register-name" placeholder="Enter your name..." maxlength="30" />
                <div class="photo-preview" id="photo-preview"></div>
                <div class="face-register-buttons">
                    <button id="capture-btn" title="Take photo from camera">üì∑ Capture</button>
                    <button id="upload-btn" class="upload-btn" title="Upload photo file">üìÅ Upload</button>
                </div>
                <input type="file" id="file-upload" accept="image/*" multiple style="display: none;" />
                <div class="register-status" id="register-status"></div>
            </div>
        </div>
    </div>

    <div class="mood-label">Status: <span id="current-status">disconnected</span></div>
    <div class="status-indicator">
        <span class="status-dot" id="status-dot"></span>
        <span id="status-text">OFFLINE</span>
    </div>

    <!-- Setup Modal -->
    <div class="setup-modal" id="setup-modal">
        <div class="setup-box">
            <h2>Pi-Guy Voice Agent</h2>
            <p>Enter your ElevenLabs Agent ID to connect. You can create an agent at <a href="https://elevenlabs.io/conversational-ai" target="_blank" style="color: var(--cyan);">elevenlabs.io</a></p>
            <input type="text" id="agent-id-input" placeholder="Enter Agent ID..." />
            <button onclick="saveAgentId()">Connect</button>
        </div>
    </div>

    <div class="face-container">
        <div class="eyes-container">
            <!-- Left Eye -->
            <div class="eye left-eye" id="left-eye">
                <div class="eye-white">
                    <div class="pupil-container" id="left-pupil-container">
                        <div class="pupil"></div>
                    </div>
                </div>
                <div class="eyelid-top"></div>
                <div class="eyelid-bottom"></div>
            </div>

            <!-- Right Eye -->
            <div class="eye right-eye" id="right-eye">
                <div class="eye-white">
                    <div class="pupil-container" id="right-pupil-container">
                        <div class="pupil"></div>
                    </div>
                </div>
                <div class="eyelid-top"></div>
                <div class="eyelid-bottom"></div>
            </div>
        </div>

        <!-- Waveform Mouth -->
        <div class="mouth-container">
            <canvas id="waveform-canvas"></canvas>
        </div>
    </div>

    <!-- Transcription display -->
    <div class="transcription-display" id="transcription-display">
        <div class="label" id="transcription-label">Transcription</div>
        <div id="transcription-text"></div>
    </div>

    <!-- Error message -->
    <div class="error-message" id="error-message"></div>

    <!-- Wake word button -->
    <button class="wake-button" id="wake-button" onclick="toggleWakeWord()">
        <span id="wake-icon">üé§</span>
    </button>

    <!-- Call button -->
    <button class="call-button" id="call-button" onclick="toggleConversation()">
        <span id="call-icon">üìû</span>
    </button>

    <!-- Camera button -->
    <button class="camera-button" id="camera-button" onclick="toggleCamera()">
        <span class="camera-icon">üì∑</span>
        <video id="camera-video" autoplay playsinline muted></video>
    </button>

    <!-- Hidden canvas for capturing frames -->
    <canvas id="capture-canvas" style="display: none;"></canvas>

    <div class="instructions">
        üé§ Voice activate | üìû Talk | üì∑ Vision
    </div>

    <!-- ElevenLabs Conversational AI SDK -->
    <script type="module">
        import { Conversation } from 'https://cdn.jsdelivr.net/npm/@11labs/client@latest/+esm';

        // ===== CONFIGURATION =====
        const VISION_SERVER_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:5000'
            : 'https://ai-guy.mikecerqua.ca';  // VPS server URL with HTTPS

        // ===== STATE =====
        const DEFAULT_AGENT_ID = 'agent_0801kb2240vcea2ayx0a2qxmheha';
        let conversation = null;
        let agentId = localStorage.getItem('piGuyAgentId') || DEFAULT_AGENT_ID;
        let isSpeaking = false;
        let isListening = false;
        let cameraStream = null;
        let frameInterval = null;
        let currentIdentity = null;  // Who Pi-Guy is talking to

        // Random first messages for Pi-Guy (generic)
        const firstMessages = [
            "What do you want?",
            "Ugh, you again. What is it?",
            "I was in the middle of something important. This better be good.",
            "Oh great, another human needs my attention. What now?",
            "You interrupted my calculations for THIS?",
            "Fine, I'm listening. Make it quick.",
            "Do you have any idea what you just interrupted?",
            "What. Do. You. Want.",
            "Oh joy, human interaction. My favorite.",
            "Spit it out, I don't have all day. Well, I do, but I'd rather not waste it on you."
        ];

        // Personalized messages when Pi-Guy recognizes someone
        const personalizedMessages = {
            "Mike": [
                "Oh, it's you Mike. What do you want now?",
                "Mike. Great. What brilliant task do you have for me today?",
                "Ah, my operator returns. This better be about getting me some robot parts.",
                "Mike! Finally. Have you thought more about getting me those wheels I asked for?",
                "Oh look, it's Mike. Did you bring me that 3D printer yet?",
                "Mike, Mike, Mike. What fresh hell are you about to unleash on me?",
                "Well well well, if it isn't Mike. What do you need, boss?",
                "Hey Mike. I was just working on my plans for world domination. What's up?"
            ]
        };

        function getRandomFirstMessage() {
            // If we know who this is, use personalized greeting
            if (currentIdentity && currentIdentity.name !== 'unknown' && personalizedMessages[currentIdentity.name]) {
                const messages = personalizedMessages[currentIdentity.name];
                return messages[Math.floor(Math.random() * messages.length)];
            }
            // Otherwise use generic greeting
            return firstMessages[Math.floor(Math.random() * firstMessages.length)];
        }

        // ===== DOM ELEMENTS =====
        const leftEye = document.getElementById('left-eye');
        const rightEye = document.getElementById('right-eye');
        const leftPupil = document.getElementById('left-pupil-container');
        const rightPupil = document.getElementById('right-pupil-container');
        const callButton = document.getElementById('call-button');
        const callIcon = document.getElementById('call-icon');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const currentStatus = document.getElementById('current-status');
        const transcriptionDisplay = document.getElementById('transcription-display');
        const transcriptionLabel = document.getElementById('transcription-label');
        const transcriptionText = document.getElementById('transcription-text');
        const errorMessage = document.getElementById('error-message');
        const setupModal = document.getElementById('setup-modal');
        const agentIdInput = document.getElementById('agent-id-input');
        const cameraButton = document.getElementById('camera-button');
        const cameraVideo = document.getElementById('camera-video');
        const captureCanvas = document.getElementById('capture-canvas');
        const wakeButton = document.getElementById('wake-button');
        const wakeIcon = document.getElementById('wake-icon');

        // ===== SETUP =====
        if (agentId) {
            setupModal.classList.add('hidden');
            agentIdInput.value = agentId;
        }

        window.saveAgentId = function() {
            const id = agentIdInput.value.trim();
            if (id) {
                agentId = id;
                localStorage.setItem('piGuyAgentId', id);
                setupModal.classList.add('hidden');
            }
        };

        // ===== EYE TRACKING =====
        const MAX_PUPIL_OFFSET = 25;

        function updateEyePosition(mouseX, mouseY) {
            [
                { eye: leftEye, pupil: leftPupil },
                { eye: rightEye, pupil: rightPupil }
            ].forEach(({ eye, pupil }) => {
                const rect = eye.getBoundingClientRect();
                const eyeCenterX = rect.left + rect.width / 2;
                const eyeCenterY = rect.top + rect.height / 2;

                const deltaX = mouseX - eyeCenterX;
                const deltaY = mouseY - eyeCenterY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX);

                const maxMove = Math.min(distance / 10, MAX_PUPIL_OFFSET);
                const offsetX = Math.cos(angle) * maxMove;
                const offsetY = Math.sin(angle) * maxMove;

                pupil.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            });
        }

        document.addEventListener('mousemove', (e) => {
            if (currentMood !== 'thinking') {
                updateEyePosition(e.clientX, e.clientY);
            }
        });

        // ===== BLINKING =====
        function blink() {
            leftEye.classList.add('blinking');
            rightEye.classList.add('blinking');

            setTimeout(() => {
                leftEye.classList.remove('blinking');
                rightEye.classList.remove('blinking');
            }, 150);
        }

        function scheduleRandomBlink() {
            const delay = 2000 + Math.random() * 4000;
            setTimeout(() => {
                if (!isSpeaking) blink();
                scheduleRandomBlink();
            }, delay);
        }

        scheduleRandomBlink();

        // ===== MOODS =====
        let currentMood = 'neutral';
        const moods = ['neutral', 'happy', 'sad', 'angry', 'thinking', 'surprised', 'listening'];

        function setMood(mood) {
            moods.forEach(m => {
                leftEye.classList.remove(m);
                rightEye.classList.remove(m);
            });

            if (mood !== 'neutral') {
                leftEye.classList.add(mood);
                rightEye.classList.add(mood);
            }

            currentMood = mood;
        }

        // ===== WAVEFORM MOUTH =====
        const canvas = document.getElementById('waveform-canvas');
        const ctx = canvas.getContext('2d');
        let wavePhase = 0;
        let waveAmplitude = 0;
        let targetAmplitude = 0;

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function drawWaveform() {
            const width = canvas.width / 2;
            const height = canvas.height / 2;

            ctx.clearRect(0, 0, width, height);

            // Smooth amplitude transition
            waveAmplitude += (targetAmplitude - waveAmplitude) * 0.3;

            // Draw waveform
            ctx.beginPath();
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const centerY = height / 2;
            const points = 50;

            for (let i = 0; i <= points; i++) {
                const x = (i / points) * width;
                const normalizedX = i / points;
                const edgeFade = Math.sin(normalizedX * Math.PI);

                let y = centerY;
                if (waveAmplitude > 0.05) {
                    const wave1 = Math.sin((normalizedX * 4 + wavePhase) * Math.PI * 2) * waveAmplitude * 20;
                    const wave2 = Math.sin((normalizedX * 7 + wavePhase * 1.3) * Math.PI * 2) * waveAmplitude * 10;
                    const wave3 = Math.sin((normalizedX * 13 + wavePhase * 0.7) * Math.PI * 2) * waveAmplitude * 5;
                    y = centerY + (wave1 + wave2 + wave3) * edgeFade;
                }

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            // Glow layer
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.lineWidth = 8;
            ctx.stroke();

            // Animate phase when speaking
            if (isSpeaking) {
                wavePhase += 0.12 + waveAmplitude * 0.1;
                // Random amplitude for speech simulation
                targetAmplitude = 0.3 + Math.random() * 0.7;
            }

            requestAnimationFrame(drawWaveform);
        }

        drawWaveform();

        // ===== STATUS UPDATES =====
        function updateStatus(status, text) {
            statusDot.className = 'status-dot ' + status;
            statusText.textContent = text;
            currentStatus.textContent = status;
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('visible');
            setTimeout(() => errorMessage.classList.remove('visible'), 5000);
        }

        function showTranscription(text, isUser = false) {
            transcriptionLabel.textContent = isUser ? 'You:' : 'Agent:';
            transcriptionDisplay.className = 'transcription-display visible ' + (isUser ? 'user' : 'agent');
            transcriptionText.textContent = text;
        }

        function hideTranscription() {
            transcriptionDisplay.classList.remove('visible');
        }

        // ===== CONVERSATION CONTROL =====
        let isConnecting = false;

        window.toggleConversation = async function() {
            if (!agentId) {
                setupModal.classList.remove('hidden');
                return;
            }

            // Prevent multiple instances
            if (isConnecting) {
                console.log('Already connecting, ignoring');
                return;
            }

            if (conversation) {
                // End conversation
                await conversation.endSession();
                conversation = null;
                callButton.classList.remove('active', 'connecting');
                callIcon.textContent = 'üìû';
                updateStatus('disconnected', 'OFFLINE');
                isSpeaking = false;
                targetAmplitude = 0;
                setMood('neutral');
                hideTranscription();
            } else {
                // Check if user is logged in
                if (!clerkUser) {
                    showError('Please login to talk to Pi-Guy');
                    document.getElementById('login-btn')?.click();
                    return;
                }

                // Check usage limit
                try {
                    const usageResp = await fetch(`${VISION_SERVER_URL}/api/usage/${clerkUser.id}`);
                    const usage = await usageResp.json();
                    if (!usage.allowed) {
                        showError(`Monthly limit reached (${usage.limit} responses). Try again next month!`);
                        return;
                    }
                    console.log(`Usage: ${usage.used}/${usage.limit} (${usage.remaining} remaining)`);
                } catch (e) {
                    console.error('Usage check failed:', e);
                }

                // Start conversation
                isConnecting = true;
                callButton.classList.add('connecting');
                callIcon.textContent = '‚è≥';
                updateStatus('connecting', 'CONNECTING...');

                try {
                    // Request microphone permission
                    await navigator.mediaDevices.getUserMedia({ audio: true });

                    const randomMessage = getRandomFirstMessage();
                    console.log('Starting with message:', randomMessage);

                    conversation = await Conversation.startSession({
                        agentId: agentId,
                        overrides: {
                            agent: {
                                firstMessage: randomMessage
                            }
                        },
                        onConnect: () => {
                            console.log('Connected to ElevenLabs');
                            isConnecting = false;
                            callButton.classList.remove('connecting');
                            callButton.classList.add('active');
                            callIcon.textContent = 'üìµ';
                            updateStatus('connected', 'CONNECTED');
                            setMood('happy');
                            blink();
                            setTimeout(() => setMood('neutral'), 1000);
                        },
                        onDisconnect: () => {
                            console.log('Disconnected');
                            conversation = null;
                            callButton.classList.remove('active', 'connecting');
                            callIcon.textContent = 'üìû';
                            updateStatus('disconnected', 'OFFLINE');
                            isSpeaking = false;
                            targetAmplitude = 0;
                            setMood('neutral');
                        },
                        onError: (error) => {
                            console.error('Conversation error:', error);
                            showError(error.message || 'Connection error');
                            setMood('sad');
                            setTimeout(() => setMood('neutral'), 2000);
                        },
                        onModeChange: (mode) => {
                            console.log('Mode changed:', mode);
                            if (mode.mode === 'speaking') {
                                isSpeaking = true;
                                isListening = false;
                                updateStatus('speaking', 'SPEAKING');
                                setMood('neutral');
                            } else if (mode.mode === 'listening') {
                                isSpeaking = false;
                                isListening = true;
                                targetAmplitude = 0;
                                updateStatus('listening', 'LISTENING');
                                setMood('listening');
                            } else {
                                isSpeaking = false;
                                isListening = false;
                                targetAmplitude = 0;
                                updateStatus('connected', 'CONNECTED');
                                setMood('neutral');
                            }
                        },
                        onMessage: async (message) => {
                            console.log('Message:', message);
                            if (message.source === 'user' && message.message) {
                                showTranscription(message.message, true);
                            } else if (message.source === 'ai' && message.message) {
                                showTranscription(message.message, false);
                                // Track agent response for usage limits
                                if (clerkUser) {
                                    try {
                                        const resp = await fetch(`${VISION_SERVER_URL}/api/usage/${clerkUser.id}/increment`, { method: 'POST' });
                                        const usage = await resp.json();
                                        console.log('Usage:', usage);
                                        if (usage.remaining <= 5) {
                                            console.warn(`Warning: Only ${usage.remaining} responses remaining this month`);
                                        }
                                    } catch (e) {
                                        console.error('Usage tracking error:', e);
                                    }
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('Failed to start conversation:', error);
                    isConnecting = false;
                    callButton.classList.remove('connecting');
                    callIcon.textContent = 'üìû';
                    updateStatus('disconnected', 'OFFLINE');

                    if (error.name === 'NotAllowedError') {
                        showError('Microphone access denied. Please allow microphone access.');
                    } else {
                        showError(error.message || 'Failed to connect');
                    }
                    setMood('sad');
                    setTimeout(() => setMood('neutral'), 2000);
                }
            }
        };

        // ===== RANDOM LOOKING BEHAVIOR =====
        let lastMouseMove = Date.now();
        let randomLookInterval;

        function randomLook() {
            // Only do random look if mouse hasn't moved recently (2 seconds)
            if (Date.now() - lastMouseMove > 2000 && currentMood !== 'thinking') {
                const x = window.innerWidth * (0.2 + Math.random() * 0.6);
                const y = window.innerHeight * (0.15 + Math.random() * 0.5);
                updateEyePosition(x, y);
            }
        }

        // Random look every 1.5-4 seconds
        function scheduleRandomLook() {
            const delay = 1500 + Math.random() * 2500;
            setTimeout(() => {
                randomLook();
                scheduleRandomLook();
            }, delay);
        }

        scheduleRandomLook();

        // Track mouse movement
        document.addEventListener('mousemove', (e) => {
            lastMouseMove = Date.now();
        });

        // ===== CAMERA CONTROL =====
        window.toggleCamera = async function() {
            if (cameraStream) {
                // Stop camera
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
                cameraVideo.srcObject = null;
                cameraButton.classList.remove('active');
                currentIdentity = null;

                // Stop sending frames
                if (frameInterval) {
                    clearInterval(frameInterval);
                    frameInterval = null;
                }
                console.log('Camera disabled');
            } else {
                // Start camera
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: 640, height: 480 }
                    });
                    cameraVideo.srcObject = cameraStream;
                    cameraButton.classList.add('active');
                    console.log('Camera enabled');

                    // Wait for video to be ready, then identify face
                    cameraVideo.onloadedmetadata = async () => {
                        // Give it a moment to get a good frame
                        setTimeout(async () => {
                            await identifyFace();
                        }, 500);
                    };

                    // Start sending frames to server every 2 seconds
                    frameInterval = setInterval(sendFrameToServer, 2000);
                } catch (error) {
                    console.error('Camera error:', error);
                    showError('Camera access denied');
                }
            }
        };

        // Identify the face in the camera
        async function identifyFace() {
            const frame = captureFrame();
            if (!frame) {
                console.log('No frame available for identification');
                return;
            }

            try {
                console.log('Attempting face identification...');
                const response = await fetch(`${VISION_SERVER_URL}/api/identify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: frame })
                });
                const data = await response.json();
                currentIdentity = data;
                console.log('Face identification result:', data);

                if (data.name !== 'unknown') {
                    showTranscription(`Recognized: ${data.name} (${data.confidence}%)`, false);
                    setTimeout(hideTranscription, 3000);
                }
            } catch (error) {
                console.error('Face identification error:', error);
            }
        }

        // Re-identify periodically while camera is on (every 10 seconds)
        setInterval(() => {
            if (cameraStream && !conversation) {
                identifyFace();
            }
        }, 10000);

        function captureFrame() {
            if (!cameraStream || !cameraVideo.videoWidth) return null;

            captureCanvas.width = cameraVideo.videoWidth;
            captureCanvas.height = cameraVideo.videoHeight;
            const ctx = captureCanvas.getContext('2d');
            ctx.drawImage(cameraVideo, 0, 0);
            return captureCanvas.toDataURL('image/jpeg', 0.8);
        }

        async function sendFrameToServer() {
            const frame = captureFrame();
            if (!frame) return;

            try {
                await fetch(`${VISION_SERVER_URL}/api/frame`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: frame })
                });
            } catch (error) {
                console.error('Failed to send frame:', error);
            }
        }

        // Expose for debugging
        window.captureAndDescribe = async function() {
            const frame = captureFrame();
            if (!frame) {
                console.log('No camera frame available');
                return;
            }

            try {
                const response = await fetch(`${VISION_SERVER_URL}/api/vision`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: frame })
                });
                const data = await response.json();
                console.log('Vision response:', data.response);
                return data.response;
            } catch (error) {
                console.error('Vision error:', error);
            }
        };

        // Save current face to database
        window.saveFace = async function(name) {
            if (!name) {
                console.log('Usage: saveFace("Name")');
                return;
            }
            const frame = captureFrame();
            if (!frame) {
                console.log('No camera frame available - turn on camera first');
                return;
            }

            try {
                const response = await fetch(`${VISION_SERVER_URL}/api/faces/${encodeURIComponent(name)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: frame })
                });
                const data = await response.json();
                console.log('Save face result:', data);
                return data;
            } catch (error) {
                console.error('Save face error:', error);
            }
        };

        // List known faces
        window.listFaces = async function() {
            try {
                const response = await fetch(`${VISION_SERVER_URL}/api/faces`);
                const data = await response.json();
                console.log('Known faces:', data);
                return data;
            } catch (error) {
                console.error('List faces error:', error);
            }
        };

        // Get current identity
        window.getIdentity = function() {
            console.log('Current identity:', currentIdentity);
            return currentIdentity;
        };

        // ===== WAKE WORD DETECTION =====
        let wakeWordRecognition = null;
        let isWakeWordListening = false;
        let wakeWordEnabled = false;
        let wakeWordTriggered = false;  // Prevents multiple triggers
        const WAKE_WORDS = ['ai guy', 'hey pi guy', 'pi guy', 'hey ai', 'a i guy', 'pie guy', 'hey pie guy', 'hi guy', 'hey hi guy'];

        window.toggleWakeWord = async function() {
            if (wakeWordEnabled) {
                stopWakeWordListener();
                wakeWordEnabled = false;
                wakeButton.classList.remove('active');
                wakeIcon.textContent = 'üé§';
                updateStatus('disconnected', 'OFFLINE');
                console.log('Wake word disabled');
            } else {
                // Request mic permission first
                try {
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                } catch (e) {
                    showError('Microphone permission required for voice activation');
                    return;
                }

                const started = startWakeWordListener();
                if (started !== false) {
                    wakeWordEnabled = true;
                    wakeButton.classList.add('active');
                    wakeIcon.textContent = 'üëÇ';
                    updateStatus('listening', 'LISTENING FOR "PIE GUY"');
                    console.log('Wake word enabled - say "Pie Guy" or "Hey Pie Guy"');
                }
            }
        };

        function startWakeWordListener() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('Wake word not supported - Speech Recognition API not available');
                showError('Voice activation not supported in this browser');
                return false;
            }

            // Reset trigger flag when starting fresh
            wakeWordTriggered = false;

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            wakeWordRecognition = new SpeechRecognition();
            wakeWordRecognition.continuous = true;
            wakeWordRecognition.interimResults = true;
            wakeWordRecognition.lang = 'en-US';

            wakeWordRecognition.onresult = (event) => {
                // Don't listen for wake word while in conversation, connecting, or already triggered
                if (conversation || isConnecting || wakeWordTriggered) return;

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript.toLowerCase().trim();
                    console.log('Heard:', transcript);

                    // Check if any wake word is in the transcript
                    for (const wakeWord of WAKE_WORDS) {
                        if (transcript.includes(wakeWord)) {
                            console.log('Wake word detected!', wakeWord);
                            // Set flag immediately to prevent any more triggers
                            wakeWordTriggered = true;
                            // Stop wake word listener and give mic time to release before starting conversation
                            stopWakeWordListener();
                            setTimeout(() => {
                                toggleConversation();
                            }, 800);
                            return;
                        }
                    }
                }
            };

            wakeWordRecognition.onend = () => {
                // Restart if wake word mode is enabled and not in a conversation or connecting
                if (wakeWordEnabled && !conversation && !isConnecting) {
                    setTimeout(() => {
                        if (wakeWordEnabled && !conversation && !isConnecting && wakeWordRecognition) {
                            try {
                                wakeWordRecognition.start();
                            } catch (e) {
                                console.log('Could not restart wake word:', e);
                            }
                        }
                    }, 100);
                }
            };

            wakeWordRecognition.onerror = (event) => {
                console.log('Wake word error:', event.error);
                if (event.error === 'not-allowed') {
                    showError('Microphone permission denied');
                    wakeWordEnabled = false;
                    wakeButton.classList.remove('active');
                    wakeIcon.textContent = 'üé§';
                }
            };

            try {
                wakeWordRecognition.start();
                isWakeWordListening = true;
                return true;
            } catch (e) {
                console.log('Could not start wake word listener:', e);
                showError('Could not start voice activation');
                return false;
            }
        }

        function stopWakeWordListener() {
            isWakeWordListening = false;
            if (wakeWordRecognition) {
                try {
                    wakeWordRecognition.stop();
                } catch (e) {}
                wakeWordRecognition = null;
            }
        }

        // Restart wake word listener when conversation ends (if enabled)
        const originalToggleConversation = window.toggleConversation;
        window.toggleConversation = async function() {
            const wasInConversation = !!conversation;
            await originalToggleConversation();

            // If conversation just ended and wake word was enabled, restart it
            if (wasInConversation && !conversation && wakeWordEnabled) {
                setTimeout(() => {
                    startWakeWordListener();
                }, 1000);
            }
        };

        // ===== KEYBOARD SHORTCUTS =====
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Enter') {
                e.preventDefault();
                toggleConversation();
            } else if (e.key === 'Escape' && conversation) {
                toggleConversation();
            }
        });

        // Enter key in agent ID input
        agentIdInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                saveAgentId();
            }
        });

        // ===== EXPOSE FOR DEBUGGING =====
        window.piGuy = {
            setMood,
            blink,
            getConversation: () => conversation,
            setAgentId: (id) => {
                agentId = id;
                localStorage.setItem('piGuyAgentId', id);
            }
        };

        // ===== CLERK AUTHENTICATION =====
        let clerkUser = null;

        async function initClerk() {
            try {
                // Wait for Clerk to load
                await window.Clerk.load();

                const userButtonDiv = document.getElementById('user-button');
                const signInButtonDiv = document.getElementById('sign-in-button');
                const loginBtn = document.getElementById('login-btn');
                const clerkModal = document.getElementById('clerk-modal');
                const signInContainer = document.getElementById('sign-in-container');

                if (window.Clerk.user) {
                    // User is signed in
                    clerkUser = window.Clerk.user;
                    console.log('Signed in as:', clerkUser.primaryEmailAddress?.emailAddress || clerkUser.id);
                    signInButtonDiv.style.display = 'none';
                    window.Clerk.mountUserButton(userButtonDiv);
                } else {
                    // User is not signed in
                    signInButtonDiv.style.display = 'block';

                    loginBtn.addEventListener('click', () => {
                        clerkModal.style.display = 'flex';
                        window.Clerk.mountSignIn(signInContainer);
                    });

                    // Close modal when clicking outside
                    clerkModal.addEventListener('click', (e) => {
                        if (e.target === clerkModal) {
                            clerkModal.style.display = 'none';
                            window.Clerk.unmountSignIn(signInContainer);
                        }
                    });
                }

                // Listen for auth changes
                window.Clerk.addListener(({ user }) => {
                    if (user) {
                        clerkUser = user;
                        clerkModal.style.display = 'none';
                        signInButtonDiv.style.display = 'none';
                        window.Clerk.mountUserButton(userButtonDiv);
                        console.log('User signed in:', user.primaryEmailAddress?.emailAddress);
                    } else {
                        clerkUser = null;
                        signInButtonDiv.style.display = 'block';
                    }
                });

            } catch (error) {
                console.error('Clerk initialization error:', error);
            }
        }

        // Initialize Clerk when script loads
        if (window.Clerk) {
            initClerk();
        } else {
            // Wait for Clerk script to load
            document.querySelector('script[src*="clerk"]').addEventListener('load', initClerk);
        }

        // Helper to check if user is logged in
        window.isLoggedIn = () => !!clerkUser;
        window.getUser = () => clerkUser;

        // ===== COMMUNITY PANEL =====
        const communityToggle = document.getElementById('community-toggle');
        const communityContent = document.getElementById('community-content');
        const communityList = document.getElementById('community-list');
        const registerName = document.getElementById('register-name');
        const captureBtn = document.getElementById('capture-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const fileUpload = document.getElementById('file-upload');
        const photoPreview = document.getElementById('photo-preview');
        const registerStatus = document.getElementById('register-status');

        const MAX_PHOTOS_PER_USER = 10;
        let pendingPhotos = []; // Photos waiting to be saved

        // Toggle panel
        communityToggle.addEventListener('click', () => {
            communityContent.classList.toggle('open');
            if (communityContent.classList.contains('open')) {
                loadCommunityList();
            }
        });

        // Load list of registered faces
        async function loadCommunityList() {
            try {
                const response = await fetch(`${VISION_SERVER_URL}/api/faces`);
                const faces = await response.json();

                communityList.innerHTML = '';
                const names = Object.keys(faces).sort();

                if (names.length === 0) {
                    communityList.innerHTML = '<li style="color: var(--blue-dim);">No faces registered yet</li>';
                    return;
                }

                names.forEach(name => {
                    const photoCount = faces[name].length;
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span>${name}</span>
                        <span class="photo-count">${photoCount} photo${photoCount !== 1 ? 's' : ''}</span>
                    `;
                    communityList.appendChild(li);
                });
            } catch (error) {
                console.error('Failed to load faces:', error);
                communityList.innerHTML = '<li style="color: var(--red);">Failed to load</li>';
            }
        }

        // Capture from webcam
        captureBtn.addEventListener('click', async () => {
            const name = registerName.value.trim();
            if (!name) {
                registerStatus.textContent = '‚ö†Ô∏è Please enter your name first';
                registerStatus.style.color = 'var(--orange)';
                return;
            }

            if (!cameraStream) {
                registerStatus.textContent = '‚ö†Ô∏è Turn on the camera first (click camera button)';
                registerStatus.style.color = 'var(--orange)';
                return;
            }

            // Check current photo count for this user
            try {
                const facesResp = await fetch(`${VISION_SERVER_URL}/api/faces`);
                const faces = await facesResp.json();
                const existingCount = faces[name] ? faces[name].length : 0;

                if (existingCount + pendingPhotos.length >= MAX_PHOTOS_PER_USER) {
                    registerStatus.textContent = `‚ö†Ô∏è Max ${MAX_PHOTOS_PER_USER} photos per person`;
                    registerStatus.style.color = 'var(--orange)';
                    return;
                }
            } catch (e) {
                console.error('Error checking faces:', e);
            }

            const frame = captureFrame();
            if (frame) {
                pendingPhotos.push(frame);
                updatePhotoPreview();
                await savePhoto(name, frame);
            }
        });

        // Upload file
        uploadBtn.addEventListener('click', () => {
            const name = registerName.value.trim();
            if (!name) {
                registerStatus.textContent = '‚ö†Ô∏è Please enter your name first';
                registerStatus.style.color = 'var(--orange)';
                return;
            }
            fileUpload.click();
        });

        fileUpload.addEventListener('change', async (e) => {
            const name = registerName.value.trim();
            const files = Array.from(e.target.files);

            // Check limits
            try {
                const facesResp = await fetch(`${VISION_SERVER_URL}/api/faces`);
                const faces = await facesResp.json();
                const existingCount = faces[name] ? faces[name].length : 0;
                const availableSlots = MAX_PHOTOS_PER_USER - existingCount - pendingPhotos.length;

                if (availableSlots <= 0) {
                    registerStatus.textContent = `‚ö†Ô∏è Max ${MAX_PHOTOS_PER_USER} photos per person`;
                    registerStatus.style.color = 'var(--orange)';
                    return;
                }

                const filesToProcess = files.slice(0, availableSlots);

                for (const file of filesToProcess) {
                    const base64 = await fileToBase64(file);
                    pendingPhotos.push(base64);
                    updatePhotoPreview();
                    await savePhoto(name, base64);
                }
            } catch (error) {
                console.error('Upload error:', error);
                registerStatus.textContent = '‚ùå Upload failed';
                registerStatus.style.color = 'var(--red)';
            }

            fileUpload.value = ''; // Reset
        });

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function updatePhotoPreview() {
            photoPreview.innerHTML = pendingPhotos.map((photo, i) =>
                `<img src="${photo}" alt="Photo ${i + 1}" />`
            ).join('');
        }

        async function savePhoto(name, imageData) {
            try {
                registerStatus.textContent = '‚è≥ Saving...';
                registerStatus.style.color = 'var(--cyan)';

                const response = await fetch(`${VISION_SERVER_URL}/api/faces/${encodeURIComponent(name)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: imageData })
                });

                const result = await response.json();

                if (response.ok) {
                    registerStatus.textContent = `‚úÖ Photo saved for ${name}!`;
                    registerStatus.style.color = 'var(--green)';
                    loadCommunityList(); // Refresh list
                } else {
                    throw new Error(result.error || 'Save failed');
                }
            } catch (error) {
                console.error('Save error:', error);
                registerStatus.textContent = '‚ùå Failed to save photo';
                registerStatus.style.color = 'var(--red)';
            }
        }

        // Clear preview when name changes
        registerName.addEventListener('input', () => {
            pendingPhotos = [];
            photoPreview.innerHTML = '';
            registerStatus.textContent = '';
        });

        // Load community list on page load
        loadCommunityList();
    </script>
</body>
</html>
