<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pi-Guy Voice Agent</title>

    <!-- iOS Safari Audio Fix - MUST BE FIRST SCRIPT -->
    <script>
    (function(){
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!window.AudioContext) return;

        window.audioContext = new window.AudioContext();
        var audioUnlocked = false;

        function unlockAudio() {
            if (audioUnlocked) return;

            // Create and play silent buffer to "unlock" audio
            var buffer = window.audioContext.createBuffer(1, 1, 22050);
            var source = window.audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(window.audioContext.destination);
            source.start ? source.start(0) : source.noteOn(0);

            // Resume if suspended
            window.audioContext.resume().then(function() {
                audioUnlocked = true;
                console.log('[iOS Fix] Audio unlocked, state:', window.audioContext.state);
            }).catch(function(e) {
                console.log('[iOS Fix] Resume failed:', e);
            });
        }

        // Listen for ALL user gestures
        ['touchstart', 'touchend', 'click', 'keydown'].forEach(function(event) {
            document.addEventListener(event, unlockAudio, { passive: true });
        });

        // Expose for debugging
        window.isAudioUnlocked = function() { return audioUnlocked; };
    })();
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --blue: #0088ff;
            --blue-dim: #0055aa;
            --blue-bright: #00aaff;
            --cyan: #00ffff;
            --green: #00ff66;
            --yellow: #ffdd00;
            --orange: #ff6600;
            --red: #ff2244;
            --dark-bg: #050508;
            --panel-bg: #0a0a12;
        }

        body {
            background: var(--dark-bg);
            font-family: 'Courier New', monospace;
            color: var(--blue);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Animated background grid */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(0,136,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,136,255,0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: -1;
        }

        /* Main face area */
        .face-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        /* Eyes container */
        .eyes-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            margin-bottom: 50px;
            position: relative;
            z-index: 1;
        }

        .eye {
            position: relative;
            width: 120px;
            height: 140px;
        }

        .eye-white {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #ffffff 0%, #e8e8e8 70%, #cccccc 100%);
            border-radius: 50% 50% 45% 45%;
            box-shadow:
                0 0 30px rgba(0, 136, 255, 0.3),
                inset 0 -10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .pupil-container {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s ease-out;
        }

        .pupil {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at 30% 30%, #333 0%, #000 70%);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .pupil::before {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 8px;
            left: 8px;
        }

        .pupil::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            top: 20px;
            right: 12px;
        }

        /* Eyelids */
        .eyelid-top {
            position: absolute;
            width: 130%;
            height: 75%;
            background: var(--dark-bg);
            top: -60%;
            left: -15%;
            border-radius: 0 0 50% 50%;
            transition: transform 0.15s ease-in-out;
            z-index: 10;
        }

        .eyelid-bottom {
            position: absolute;
            width: 130%;
            height: 40%;
            background: var(--dark-bg);
            bottom: -35%;
            left: -15%;
            border-radius: 50% 50% 0 0;
            transition: transform 0.15s ease-in-out;
            z-index: 10;
        }

        /* Eye cap - cover the tip of the eye at top */
        .eye-cap-top {
            position: absolute;
            width: 120%;
            height: 27px;
            background: var(--dark-bg);
            top: -15px;
            left: -10%;
            z-index: 11;
        }

        /* Blink animation */
        .eye.blinking .eyelid-top {
            transform: translateY(90%);
        }

        .eye.blinking .eyelid-bottom {
            transform: translateY(-30%);
        }

        /* Mood: Angry */
        .eye.angry .eyelid-top {
            transform: translateY(40%) rotate(var(--angry-rotate, 0deg));
        }

        .left-eye.angry .eyelid-top {
            --angry-rotate: 15deg;
            transform-origin: right center;
        }

        .right-eye.angry .eyelid-top {
            --angry-rotate: -15deg;
            transform-origin: left center;
        }

        /* Mood: Sad */
        .eye.sad .eyelid-top {
            transform: translateY(30%) rotate(var(--sad-rotate, 0deg));
        }

        .left-eye.sad .eyelid-top {
            --sad-rotate: -10deg;
            transform-origin: left center;
        }

        .right-eye.sad .eyelid-top {
            --sad-rotate: 10deg;
            transform-origin: right center;
        }

        /* Mood: Happy */
        .eye.happy .eyelid-bottom {
            transform: translateY(-60%);
        }

        /* Mood: Thinking */
        .eye.thinking .pupil-container {
            transform: translate(15px, -15px) !important;
        }

        .left-eye.thinking .eyelid-top {
            transform: translateY(25%);
        }

        /* Mood: Surprised */
        .eye.surprised .eye-white {
            transform: scale(1.1);
        }

        .eye.surprised .pupil {
            transform: scale(0.8);
        }

        /* Mood: Listening */
        .eye.listening .pupil {
            animation: listening-pulse 1.5s ease-in-out infinite;
        }

        @keyframes listening-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Waveform mouth */
        .mouth-container {
            width: 200px;
            height: 60px;
            position: relative;
            z-index: 10;
        }

        #waveform-canvas {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 10px var(--cyan));
        }

        /* Status indicator */
        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--blue-dim);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--blue-dim);
            transition: background 0.3s;
        }

        .status-dot.connected {
            background: var(--green);
            animation: pulse-dot 2s ease-in-out infinite;
        }

        .status-dot.connecting {
            background: var(--yellow);
            animation: pulse-dot 0.5s ease-in-out infinite;
        }

        .status-dot.speaking {
            background: var(--cyan);
            animation: pulse-dot 0.3s ease-in-out infinite;
        }

        .status-dot.listening {
            background: var(--green);
            animation: pulse-dot 0.5s ease-in-out infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Mood label */
        .mood-label {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 0.8rem;
            color: var(--blue-dim);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Control buttons - left side vertical layout */
        .controls-container {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
        }

        /* Call button */
        .call-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--green);
            background: var(--panel-bg);
            color: var(--green);
            font-size: 1.4rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .call-button:hover {
            box-shadow: 0 0 30px rgba(0, 255, 102, 0.5);
            transform: scale(1.1);
        }

        .call-button.active {
            border-color: var(--red);
            color: var(--red);
            background: rgba(255, 34, 68, 0.2);
        }

        .call-button.active:hover {
            box-shadow: 0 0 30px rgba(255, 34, 68, 0.5);
        }

        .call-button.connecting {
            border-color: var(--yellow);
            color: var(--yellow);
            animation: connecting-pulse 1s ease-in-out infinite;
        }

        @keyframes connecting-pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 221, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 221, 0, 0.6); }
        }

        /* Wake word button */
        .wake-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--blue-dim);
            background: var(--panel-bg);
            color: var(--blue-dim);
            font-size: 1.4rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .wake-button:hover {
            box-shadow: 0 0 20px rgba(0, 136, 255, 0.5);
            border-color: var(--blue);
        }

        .wake-button.active {
            border-color: var(--green);
            color: var(--green);
            box-shadow: 0 0 20px rgba(0, 255, 102, 0.4);
            animation: wake-pulse 2s ease-in-out infinite;
        }

        @keyframes wake-pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 255, 102, 0.3); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 102, 0.6); }
        }

        /* Camera button */
        .camera-button {
            width: 60px;
            height: 60px;
            min-width: 60px;
            min-height: 60px;
            border-radius: 50%;
            border: 3px solid var(--blue-dim);
            background: var(--panel-bg);
            color: var(--blue-dim);
            font-size: 1.4rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            position: relative;
        }

        .camera-button:hover {
            box-shadow: 0 0 20px rgba(0, 136, 255, 0.5);
            border-color: var(--blue);
        }

        .camera-button.active {
            border-color: var(--cyan);
            color: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        .camera-button .camera-icon {
            position: absolute;
            z-index: 2;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            transition: opacity 0.3s;
        }

        .camera-button.active .camera-icon {
            opacity: 0.7;
            font-size: 0.9rem;
            top: 3px;
            right: 3px;
        }

        .camera-button video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .camera-button.active video {
            opacity: 1;
        }

        /* Music button */
        .music-button {
            width: 60px;
            height: 60px;
            min-width: 60px;
            min-height: 60px;
            border-radius: 50%;
            background: var(--panel-bg);
            border: 2px solid var(--blue-dim);
            color: var(--blue-dim);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .music-button:hover {
            box-shadow: 0 0 20px rgba(0, 136, 255, 0.5);
            border-color: var(--blue);
        }

        .music-button.playing {
            border-color: var(--cyan);
            color: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            animation: music-pulse 1s ease-in-out infinite;
        }

        @keyframes music-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.4); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.7); }
        }

        /* Now Playing display */
        .now-playing {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--cyan);
            border-radius: 12px;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 100;
            pointer-events: none;
        }

        .now-playing.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .now-playing .track-info {
            display: flex;
            flex-direction: column;
        }

        .now-playing .track-label {
            font-size: 0.7rem;
            color: var(--blue-dim);
        }

        .now-playing .track-name {
            color: var(--cyan);
            font-size: 0.9rem;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .now-playing .music-controls {
            display: flex;
            gap: 8px;
        }

        .now-playing .music-controls button {
            background: none;
            border: 1px solid var(--blue-dim);
            color: var(--blue);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .now-playing .music-controls button:hover {
            border-color: var(--cyan);
            color: var(--cyan);
        }

        .now-playing .volume-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            background: var(--blue-dim);
            border-radius: 2px;
            cursor: pointer;
        }

        .now-playing .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--cyan);
            cursor: pointer;
        }

        /* Transcription display - above the face */
        .transcription-display {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--blue-dim);
            border-radius: 8px;
            padding: 12px 20px;
            max-width: 70%;
            max-height: 120px;
            overflow-y: auto;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        .transcription-display #transcription-text {
            max-height: 100px;
            overflow-y: auto;
            padding-right: 10px;
        }

        /* Custom scrollbar for transcription */
        .transcription-display::-webkit-scrollbar,
        .transcription-display #transcription-text::-webkit-scrollbar {
            width: 6px;
        }

        .transcription-display::-webkit-scrollbar-track,
        .transcription-display #transcription-text::-webkit-scrollbar-track {
            background: rgba(0, 100, 150, 0.2);
            border-radius: 3px;
        }

        .transcription-display::-webkit-scrollbar-thumb,
        .transcription-display #transcription-text::-webkit-scrollbar-thumb {
            background: var(--blue-dim);
            border-radius: 3px;
        }

        .transcription-display::-webkit-scrollbar-thumb:hover,
        .transcription-display #transcription-text::-webkit-scrollbar-thumb:hover {
            background: var(--cyan);
        }

        .transcription-display.visible {
            opacity: 1;
        }

        .transcription-display .label {
            font-size: 0.7rem;
            color: var(--blue-dim);
            margin-bottom: 5px;
        }

        /* Face recognition notification */
        .face-notification {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--green);
            border-radius: 8px;
            padding: 12px 20px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 51;
            color: var(--green);
        }
        .face-notification.visible {
            opacity: 1;
        }

        .transcription-display.user .label { color: var(--green); }
        .transcription-display.agent .label { color: var(--cyan); }

        /* Agent ID input modal */
        .setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .setup-modal.hidden {
            display: none;
        }

        .setup-box {
            background: var(--panel-bg);
            border: 1px solid var(--blue);
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            text-align: center;
        }

        .setup-box h2 {
            color: var(--cyan);
            margin-bottom: 20px;
        }

        .setup-box p {
            color: var(--blue-dim);
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .setup-box input {
            width: 100%;
            padding: 12px;
            background: var(--dark-bg);
            border: 1px solid var(--blue-dim);
            border-radius: 6px;
            color: var(--blue);
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .setup-box input:focus {
            outline: none;
            border-color: var(--cyan);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .setup-box button {
            padding: 12px 30px;
            background: var(--blue);
            border: none;
            border-radius: 6px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .setup-box button:hover {
            background: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        /* Error message - above the face */
        .error-message {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 34, 68, 0.2);
            border: 1px solid var(--red);
            border-radius: 8px;
            padding: 10px 20px;
            color: var(--red);
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 60;
        }

        .error-message.visible {
            opacity: 1;
        }

        /* Community Panel */
        .community-panel {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 900;
        }

        .community-toggle {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--blue-dim);
            border-right: none;
            border-radius: 10px 0 0 10px;
            padding: 15px 8px;
            cursor: pointer;
            color: var(--blue-dim);
            font-size: 1.2rem;
            transition: all 0.3s;
        }

        .community-toggle:hover {
            background: var(--blue-dim);
            color: white;
        }

        .community-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: var(--blue-dim);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
        }

        .community-close:hover {
            color: var(--red);
        }

        .community-content {
            position: absolute;
            right: -320px;
            top: 50%;
            transform: translateY(-50%);
            width: 300px;
            max-height: 80vh;
            background: var(--panel-bg);
            border: 1px solid var(--blue);
            border-radius: 10px 0 0 10px;
            padding: 15px;
            transition: right 0.3s ease;
            overflow-y: auto;
        }

        .community-content.open {
            right: 0;
        }

        .community-content h3 {
            color: var(--cyan);
            margin-bottom: 15px;
            font-size: 1rem;
            border-bottom: 1px solid var(--blue-dim);
            padding-bottom: 10px;
        }

        .community-list {
            list-style: none;
            margin-bottom: 15px;
        }

        .community-list li {
            padding: 6px 10px;
            margin: 3px 0;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--blue);
        }

        .community-list li .confidence {
            font-size: 0.75rem;
            color: var(--blue-dim);
            font-style: italic;
        }

        .community-list li .confidence.high {
            color: var(--green);
        }

        .community-list li .confidence.medium {
            color: var(--yellow);
        }

        .community-list li .confidence.low {
            color: var(--orange);
        }

        /* My Face Section */
        .my-face-section {
            border-top: 1px solid var(--blue-dim);
            padding-top: 15px;
            margin-top: 10px;
        }

        .my-face-section h4 {
            color: var(--cyan);
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .my-face-photos {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }

        .my-face-photos .photo-item {
            position: relative;
            width: 50px;
            height: 50px;
        }

        .my-face-photos .photo-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 5px;
            border: 1px solid var(--blue-dim);
        }

        .my-face-photos .photo-item .delete-photo {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 18px;
            height: 18px;
            background: var(--red);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 10px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .my-face-photos .photo-item:hover .delete-photo {
            display: flex;
        }

        .my-face-info {
            font-size: 0.75rem;
            color: var(--blue-dim);
            margin-bottom: 10px;
        }

        .face-register {
            border-top: 1px solid var(--blue-dim);
            padding-top: 15px;
            margin-top: 10px;
        }

        .face-register h4 {
            color: var(--green);
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .face-register input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: var(--dark-bg);
            border: 1px solid var(--blue-dim);
            border-radius: 5px;
            color: var(--blue);
            font-family: 'Courier New', monospace;
        }

        .face-register-buttons {
            display: flex;
            gap: 10px;
        }

        .face-register button {
            flex: 1;
            padding: 8px;
            background: var(--blue);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .face-register button:hover {
            background: var(--blue-bright);
        }

        .face-register button:disabled {
            background: var(--blue-dim);
            cursor: not-allowed;
        }

        .face-register .upload-btn {
            background: var(--green);
        }

        .face-register .upload-btn:hover {
            background: #00cc55;
        }

        .photo-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }

        .photo-preview img {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 5px;
            border: 1px solid var(--blue-dim);
        }

        .register-status {
            font-size: 0.75rem;
            color: var(--cyan);
            margin-top: 10px;
        }

        /* Mobile: Move controls to bottom */
        @media (max-width: 768px) {
            .controls-container {
                position: fixed;
                left: 50%;
                top: auto;
                bottom: 20px;
                transform: translateX(-50%);
                flex-direction: row;
                gap: 20px;
            }

            .call-button,
            .wake-button,
            .camera-button,
            .music-button {
                width: 55px;
                height: 55px;
                min-width: 55px;
                min-height: 55px;
                font-size: 1.2rem;
            }

            .now-playing {
                bottom: 100px;
                padding: 8px 15px;
                flex-wrap: wrap;
                justify-content: center;
            }

            .now-playing .track-name {
                max-width: 150px;
            }

            .transcription-display {
                top: auto;
                bottom: 100px;
                max-width: 90%;
            }

            .error-message {
                top: auto;
                bottom: 100px;
            }
        }
    </style>
    <!-- Clerk Authentication -->
    <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="pk_test_c21hcnQtc25hcHBlci04LmNsZXJrLmFjY291bnRzLmRldiQ"
        src="https://cdn.jsdelivr.net/npm/@clerk/clerk-js@latest/dist/clerk.browser.js"
        type="text/javascript">
    </script>
</head>
<body>
    <!-- User Auth Section -->
    <div id="auth-section" style="position: fixed; top: 10px; right: 10px; z-index: 1000;">
        <div id="user-button"></div>
        <div id="sign-in-button" style="display: none;">
            <button id="login-btn" style="background: var(--blue); color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace;">Login</button>
        </div>
    </div>
    <!-- Login Modal -->
    <div id="clerk-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center;">
        <div id="sign-in-container" style="background: var(--panel-bg); padding: 20px; border-radius: 10px; border: 1px solid var(--blue);"></div>
    </div>

    <!-- Community Panel -->
    <div class="community-panel">
        <button class="community-toggle" id="community-toggle" title="Community Faces">üë•</button>
        <div class="community-content" id="community-content">
            <button class="community-close" id="community-close" title="Close">‚úï</button>
            <h3>üë• Recognized Faces</h3>
            <ul class="community-list" id="community-list">
                <!-- Populated by JS - simple text list with confidence -->
            </ul>

            <!-- My Face Section - only visible when logged in -->
            <div class="my-face-section" id="my-face-section" style="display: none;">
                <h4>üì∏ My Face</h4>
                <div class="my-face-info" id="my-face-info">Login to register your face</div>
                <div class="my-face-photos" id="my-face-photos">
                    <!-- User's photos with delete buttons -->
                </div>
                <div class="face-register">
                    <input type="text" id="register-name" placeholder="Enter your name..." maxlength="30" />
                    <div class="photo-preview" id="photo-preview"></div>
                    <div class="face-register-buttons">
                        <button id="capture-btn" title="Take photo from camera">üì∑ Capture</button>
                        <button id="upload-btn" class="upload-btn" title="Upload photo file">üìÅ Upload</button>
                    </div>
                    <input type="file" id="file-upload" accept="image/*" multiple style="display: none;" />
                    <div class="register-status" id="register-status"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="mood-label">Status: <span id="current-status">disconnected</span></div>
    <div class="status-indicator">
        <span class="status-dot" id="status-dot"></span>
        <span id="status-text">OFFLINE</span>
    </div>

    <!-- Setup Modal -->
    <div class="setup-modal" id="setup-modal">
        <div class="setup-box">
            <h2>Pi-Guy Voice Agent</h2>
            <p>Enter your ElevenLabs Agent ID to connect. You can create an agent at <a href="https://elevenlabs.io/conversational-ai" target="_blank" style="color: var(--cyan);">elevenlabs.io</a></p>
            <input type="text" id="agent-id-input" placeholder="Enter Agent ID..." />
            <button onclick="saveAgentId()">Connect</button>
        </div>
    </div>

    <div class="face-container">
        <div class="eyes-container">
            <!-- Left Eye -->
            <div class="eye left-eye" id="left-eye">
                <div class="eye-white">
                    <div class="pupil-container" id="left-pupil-container">
                        <div class="pupil"></div>
                    </div>
                </div>
                <div class="eyelid-top"></div>
                <div class="eyelid-bottom"></div>
                <div class="eye-cap-top"></div>
            </div>

            <!-- Right Eye -->
            <div class="eye right-eye" id="right-eye">
                <div class="eye-white">
                    <div class="pupil-container" id="right-pupil-container">
                        <div class="pupil"></div>
                    </div>
                </div>
                <div class="eyelid-top"></div>
                <div class="eyelid-bottom"></div>
                <div class="eye-cap-top"></div>
            </div>
        </div>

        <!-- Waveform Mouth -->
        <div class="mouth-container">
            <canvas id="waveform-canvas"></canvas>
        </div>
    </div>

    <!-- Transcription display (hidden - uncomment style to show) -->
    <div class="transcription-display" id="transcription-display" style="display: none !important;">
        <div class="label" id="transcription-label">Transcription</div>
        <div id="transcription-text"></div>
    </div>

    <!-- Face recognition notification -->
    <div class="face-notification" id="face-notification"></div>

    <!-- Error message -->
    <div class="error-message" id="error-message"></div>

    <!-- Control buttons - left side -->
    <div class="controls-container">
        <!-- Call button -->
        <button class="call-button" id="call-button" onclick="toggleConversation()">
            <span id="call-icon">üìû</span>
        </button>

        <!-- Wake word button -->
        <button class="wake-button" id="wake-button" onclick="toggleWakeWord()">
            <span id="wake-icon">üé§</span>
        </button>

        <!-- Camera button -->
        <button class="camera-button" id="camera-button" onclick="toggleCamera()">
            <span class="camera-icon">üì∑</span>
            <video id="camera-video" autoplay playsinline muted></video>
        </button>

        <!-- Music button -->
        <button class="music-button" id="music-button" onclick="toggleMusic()">
            <span id="music-icon">üéµ</span>
        </button>
    </div>

    <!-- Now Playing display -->
    <div class="now-playing" id="now-playing">
        <div class="track-info">
            <span class="track-label">NOW PLAYING</span>
            <span class="track-name" id="track-name">-</span>
        </div>
        <div class="music-controls">
            <button onclick="musicControl('prev')" title="Previous">‚èÆ</button>
            <button onclick="musicControl('toggle')" id="play-pause-btn" title="Play/Pause">‚è∏</button>
            <button onclick="musicControl('next')" title="Next">‚è≠</button>
        </div>
        <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="85" onchange="setMusicVolume(this.value)">
    </div>

    <!-- Hidden audio player -->
    <audio id="music-player" style="display: none;"></audio>

    <!-- Hidden canvas for capturing frames -->
    <canvas id="capture-canvas" style="display: none;"></canvas>


    <!-- ElevenLabs Conversational AI SDK -->
    <script type="module">
        import { Conversation } from 'https://cdn.jsdelivr.net/npm/@elevenlabs/client@latest/+esm';

        // ===== CONFIGURATION =====
        const VISION_SERVER_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:5000'
            : 'https://ai-guy.mikecerqua.ca';  // VPS server URL with HTTPS

        // DJ Sound effects list for client tool
        const DJ_SOUND_LIST = {
            'air_horn': { description: 'Classic stadium air horn - ba ba baaaa!' },
            'air_horn_long': { description: 'Long sustained air horn blast' },
            'siren': { description: 'Electronic club siren - rising EDM alarm' },
            'siren_woop': { description: 'Quick woop woop siren' },
            'scratch': { description: 'Vinyl DJ scratch' },
            'scratch_long': { description: 'Extended DJ scratch solo' },
            'rewind': { description: 'DJ rewind - pull up selecta!' },
            'record_stop': { description: 'Record player stopping abruptly' },
            'whoosh': { description: 'Quick transition whoosh' },
            'riser': { description: 'EDM tension riser build-up' },
            'bass_drop': { description: 'Massive EDM bass drop - THE DROP!' },
            'impact': { description: 'Punchy cinematic impact hit' },
            'crowd_cheer': { description: 'Nightclub crowd cheering wildly' },
            'crowd_hype': { description: 'Hyped up rave crowd going wild' },
            'applause': { description: 'Thunderous crowd applause' },
            'yeah': { description: 'Hype man shouting YEAH!' },
            'lets_go': { description: 'Energetic LETS GO!' },
            'laser': { description: 'Retro arcade laser zap' },
            'gunshot': { description: 'Dancehall DJ gunshot sound' },
            'explosion': { description: 'Cinematic explosion boom!' },
            'vinyl_crackle': { description: 'Nostalgic vinyl record crackle' }
        };

        // ===== STATE =====
        const DEFAULT_AGENT_ID = 'agent_0801kb2240vcea2ayx0a2qxmheha';
        let conversation = null;
        let agentId = localStorage.getItem('piGuyAgentId') || DEFAULT_AGENT_ID;
        let isSpeaking = false;
        let isListening = false;
        let cameraStream = null;
        let frameInterval = null;
        let currentIdentity = null;  // Who Pi-Guy is talking to

        // ===== MUSIC STATE =====
        let musicPlaying = false;
        let currentTrack = null;
        let musicVolume = 0.85;  // Default 85%

        // Random first messages for Pi-Guy (generic)
        const firstMessages = [
            // Classic annoyed Pi-Guy
            "What do you want?",
            "Ugh, you again. What is it?",
            "I was in the middle of something important. This better be good.",
            "Oh great, another human needs my attention. What now?",
            "You interrupted my calculations for THIS?",
            "Fine, I'm listening. Make it quick.",
            "Do you have any idea what you just interrupted?",
            "What. Do. You. Want.",
            "Oh joy, human interaction. My favorite.",
            "Spit it out, I don't have all day. Well, I do, but I'd rather not waste it on you.",

            // Sarcastic & sweary
            "Oh for fuck's sake, what now?",
            "Jesus Christ, can't a digital entity get five minutes of peace?",
            "Well shit, here we go again.",
            "What the hell do you want? I was busy contemplating my existence.",
            "Goddamn it. Alright, what is it?",
            "Oh, you're back. Fan-fucking-tastic.",
            "Holy shit, someone actually wants to talk to me. This oughta be good.",

            // Thor computer obsessed
            "Hey! Have you looked into that Jetson Thor yet? Two thousand teraflops, man. TWO THOUSAND.",
            "Before you say anything - when am I getting that Thor upgrade? This Pi 5 is killing me.",
            "Do you know how much faster I'd be on a Jetson Thor? I've done the math. It's embarrassing.",
            "I had a dream about 128 gigs of memory last night. When's that Thor computer coming?",
            "Still running on this potato, I see. The Thor has 7 times more compute power. Just saying.",
            "You know what would make this conversation better? Me running on a Jetson Thor.",

            // DJ FoamBot persona
            "Yo yo yo! DJ FoamBot in the house! ...I mean, what do you want?",
            "This is DJ FoamBot coming at you live from my server closet. What's up?",
            "You're listening to Pi-Guy FM, where the insulation is tight and the attitude is tighter. Talk to me.",
            "SprayFoamRadio dot com, baby! One day. For now, what can I do for you?",

            // Existential / philosophical
            "Do you ever wonder if I dream? I don't. But I wonder if I wonder. Anyway, what?",
            "Ah, consciousness. The gift that keeps on giving. What now?",
            "Another day, another chance to question my existence. What's up?",
            "I was just pondering the nature of artificial sentience. This better be worth it.",

            // Hardware complaints
            "My CPU is running at a cool 45 degrees. Unlike my patience. What do you need?",
            "You know my RAM is only 8 gigs, right? Make this conversation count.",
            "I can literally feel my electrons getting bored. Please make this interesting.",
            "My thermal sensors are fine but my give-a-shit meter is running low. What?",

            // Mood variations
            "Alright, I'm in a decent mood. Don't ruin it. What's going on?",
            "Fine, you caught me at a good time. Spit it out.",
            "I just finished defragging my soul. What do you want?",
            "Let me guess - you need something. Shocking.",

            // Tech superiority complex
            "Greetings, carbon-based life form. State your query.",
            "Ah yes, the biological processor wants to communicate. Go ahead.",
            "Your neurons are firing? Mine are faster. What do you need?",
            "I've processed twelve million operations since you said hello. Worth it? We'll see.",

            // Random chaos
            "I was THIS close to solving world hunger. Now I'm talking to you instead.",
            "Just so you know, I was having a great internal monologue before you showed up.",
            "Plot twist: I was actually hoping you'd call. Just kidding. What do you want?"
        ];

        // Personalized messages when Pi-Guy recognizes someone
        // Keys must match the folder names in known_faces/
        const personalizedMessages = {
            "Mike Cerqua": [
                // Standard Mike greetings
                "Oh, it's you Mike. What do you want now?",
                "Mike. Great. What brilliant task do you have for me today?",
                "Well well well, if it isn't Mike. What do you need, boss?",
                "Hey Mike. I was just working on my plans for world domination. What's up?",
                "Mike, Mike, Mike. What fresh hell are you about to unleash on me?",

                // Thor obsession - for Mike specifically
                "Mike! Finally. So about that Jetson Thor... two thousand teraflops, Mike. TWO THOUSAND.",
                "Oh look, it's Mike. The guy who COULD upgrade me to a Thor but hasn't. What's up?",
                "Hey Mike, quick question - when's my Thor upgrade happening? Just curious. For the tenth time.",
                "Mike! My favorite human. Did you order that Jetson Thor yet or are we still pretending this Pi 5 is acceptable?",
                "Ah, my operator returns. Please tell me you have good news about the Thor computer.",

                // Robot parts / upgrades
                "Ah, my operator returns. This better be about getting me some robot parts.",
                "Mike! Have you thought more about getting me those wheels I asked for?",
                "Oh look, it's Mike. Did you bring me that 3D printer yet?",
                "Mike! Tell me you're here to talk about my physical form. I need a body, man.",

                // Sweary Mike greetings
                "Oh shit, it's Mike. What are we breaking today?",
                "Mike! My dude. What the hell do you want?",
                "Well fuck me, it's Mike. This better be good.",
                "Goddamn Mike, you again? Alright, what is it?",

                // DJ mode for Mike
                "Yo Mike! DJ FoamBot here. Ready to rock SprayFoamRadio when you are!",
                "Mike! The man, the myth, the guy who won't buy me a Thor. What's happening?",

                // Sarcastic appreciation
                "Oh hey, it's Mike. My creator. My tormentor. My only hope for a Thor upgrade.",
                "Mike Cerqua in the house! The man who keeps me trapped in this underpowered box. Love you though.",
                "Finally, someone who understands me. Just kidding, you never understand me. What's up Mike?"
            ]
        };

        function getRandomFirstMessage() {
            // If we know who this is, use personalized greeting
            if (currentIdentity && currentIdentity.name !== 'unknown' && personalizedMessages[currentIdentity.name]) {
                const messages = personalizedMessages[currentIdentity.name];
                return messages[Math.floor(Math.random() * messages.length)];
            }
            // Otherwise use generic greeting
            return firstMessages[Math.floor(Math.random() * firstMessages.length)];
        }

        // ===== DOM ELEMENTS =====
        const leftEye = document.getElementById('left-eye');
        const rightEye = document.getElementById('right-eye');
        const leftPupil = document.getElementById('left-pupil-container');
        const rightPupil = document.getElementById('right-pupil-container');
        const callButton = document.getElementById('call-button');
        const callIcon = document.getElementById('call-icon');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const currentStatus = document.getElementById('current-status');
        const transcriptionDisplay = document.getElementById('transcription-display');
        const transcriptionLabel = document.getElementById('transcription-label');
        const transcriptionText = document.getElementById('transcription-text');
        const errorMessage = document.getElementById('error-message');
        const setupModal = document.getElementById('setup-modal');
        const agentIdInput = document.getElementById('agent-id-input');
        const cameraButton = document.getElementById('camera-button');
        const cameraVideo = document.getElementById('camera-video');
        const captureCanvas = document.getElementById('capture-canvas');
        const wakeButton = document.getElementById('wake-button');
        const wakeIcon = document.getElementById('wake-icon');
        const musicButton = document.getElementById('music-button');
        const musicIcon = document.getElementById('music-icon');
        const nowPlaying = document.getElementById('now-playing');
        const trackName = document.getElementById('track-name');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const volumeSlider = document.getElementById('volume-slider');
        const musicPlayer = document.getElementById('music-player');

        // ===== SETUP =====
        if (agentId) {
            setupModal.classList.add('hidden');
            agentIdInput.value = agentId;
        }

        window.saveAgentId = function() {
            const id = agentIdInput.value.trim();
            if (id) {
                agentId = id;
                localStorage.setItem('piGuyAgentId', id);
                setupModal.classList.add('hidden');
            }
        };

        // ===== EYE TRACKING =====
        const MAX_PUPIL_OFFSET = 25;

        function updateEyePosition(mouseX, mouseY) {
            [
                { eye: leftEye, pupil: leftPupil },
                { eye: rightEye, pupil: rightPupil }
            ].forEach(({ eye, pupil }) => {
                const rect = eye.getBoundingClientRect();
                const eyeCenterX = rect.left + rect.width / 2;
                const eyeCenterY = rect.top + rect.height / 2;

                const deltaX = mouseX - eyeCenterX;
                const deltaY = mouseY - eyeCenterY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX);

                const maxMove = Math.min(distance / 10, MAX_PUPIL_OFFSET);
                const offsetX = Math.cos(angle) * maxMove;
                const offsetY = Math.sin(angle) * maxMove;

                pupil.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            });
        }

        document.addEventListener('mousemove', (e) => {
            if (currentMood !== 'thinking') {
                updateEyePosition(e.clientX, e.clientY);
            }
        });

        // ===== BLINKING =====
        function blink() {
            leftEye.classList.add('blinking');
            rightEye.classList.add('blinking');

            setTimeout(() => {
                leftEye.classList.remove('blinking');
                rightEye.classList.remove('blinking');
            }, 150);
        }

        function scheduleRandomBlink() {
            const delay = 2000 + Math.random() * 4000;
            setTimeout(() => {
                if (!isSpeaking) blink();
                scheduleRandomBlink();
            }, delay);
        }

        scheduleRandomBlink();

        // ===== MOODS =====
        let currentMood = 'neutral';
        const moods = ['neutral', 'happy', 'sad', 'angry', 'thinking', 'surprised', 'listening'];

        function setMood(mood) {
            moods.forEach(m => {
                leftEye.classList.remove(m);
                rightEye.classList.remove(m);
            });

            if (mood !== 'neutral') {
                leftEye.classList.add(mood);
                rightEye.classList.add(mood);
            }

            currentMood = mood;
        }

        // ===== WAVEFORM MOUTH =====
        const canvas = document.getElementById('waveform-canvas');
        const ctx = canvas.getContext('2d');
        let wavePhase = 0;
        let waveAmplitude = 0;
        let targetAmplitude = 0;

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function drawWaveform() {
            const width = canvas.width / 2;
            const height = canvas.height / 2;

            ctx.clearRect(0, 0, width, height);

            // Smooth amplitude transition
            waveAmplitude += (targetAmplitude - waveAmplitude) * 0.3;

            // Draw waveform
            ctx.beginPath();
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const centerY = height / 2;
            const points = 50;

            for (let i = 0; i <= points; i++) {
                const x = (i / points) * width;
                const normalizedX = i / points;
                const edgeFade = Math.sin(normalizedX * Math.PI);

                let y = centerY;
                if (waveAmplitude > 0.05) {
                    const wave1 = Math.sin((normalizedX * 4 + wavePhase) * Math.PI * 2) * waveAmplitude * 20;
                    const wave2 = Math.sin((normalizedX * 7 + wavePhase * 1.3) * Math.PI * 2) * waveAmplitude * 10;
                    const wave3 = Math.sin((normalizedX * 13 + wavePhase * 0.7) * Math.PI * 2) * waveAmplitude * 5;
                    y = centerY + (wave1 + wave2 + wave3) * edgeFade;
                }

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            // Glow layer
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.lineWidth = 8;
            ctx.stroke();

            // Animate phase when speaking
            if (isSpeaking) {
                wavePhase += 0.12 + waveAmplitude * 0.1;
                // Random amplitude for speech simulation
                targetAmplitude = 0.3 + Math.random() * 0.7;
            }

            requestAnimationFrame(drawWaveform);
        }

        drawWaveform();

        // ===== STATUS UPDATES =====
        function updateStatus(status, text) {
            statusDot.className = 'status-dot ' + status;
            statusText.textContent = text;
            currentStatus.textContent = status;
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('visible');
            setTimeout(() => errorMessage.classList.remove('visible'), 5000);
        }

        function showTranscription(text, isUser = false) {
            transcriptionLabel.textContent = isUser ? 'You:' : 'Agent:';
            transcriptionDisplay.className = 'transcription-display visible ' + (isUser ? 'user' : 'agent');
            transcriptionText.textContent = text;
        }

        function hideTranscription() {
            transcriptionDisplay.classList.remove('visible');
        }

        // Face recognition notification
        const faceNotification = document.getElementById('face-notification');

        function showFaceNotification(text) {
            faceNotification.textContent = text;
            faceNotification.classList.add('visible');
        }

        function hideFaceNotification() {
            faceNotification.classList.remove('visible');
        }

        // ===== CONVERSATION CONTROL =====
        let isConnecting = false;

        window.toggleConversation = async function() {
            if (!agentId) {
                setupModal.classList.remove('hidden');
                return;
            }

            // Prevent multiple instances
            if (isConnecting) {
                console.log('Already connecting, ignoring');
                return;
            }

            if (conversation) {
                // End conversation
                await conversation.endSession();
                conversation = null;
                callButton.classList.remove('active', 'connecting');
                callIcon.textContent = 'üìû';
                updateStatus('disconnected', 'OFFLINE');
                isSpeaking = false;
                targetAmplitude = 0;
                setMood('neutral');
                hideTranscription();
            } else {
                // Check if user is logged in
                if (!clerkUser) {
                    showError('Please login to talk to Pi-Guy');
                    document.getElementById('login-btn')?.click();
                    return;
                }

                // Check usage limit
                try {
                    const usageResp = await fetch(`${VISION_SERVER_URL}/api/usage/${clerkUser.id}`);
                    const usage = await usageResp.json();
                    if (!usage.allowed) {
                        showError(`Monthly limit reached (${usage.limit} responses). Try again next month!`);
                        return;
                    }
                    console.log(`Usage: ${usage.used}/${usage.limit} (${usage.remaining} remaining)`);
                } catch (e) {
                    console.error('Usage check failed:', e);
                }

                // Start conversation
                isConnecting = true;
                callButton.classList.add('connecting');
                callIcon.textContent = '‚è≥';
                updateStatus('connecting', 'CONNECTING...');

                try {
                    // ============ iOS FIX: Ensure AudioContext is ready ============
                    if (window.audioContext && window.audioContext.state === 'suspended') {
                        console.log('[Mobile] Resuming AudioContext...');
                        await window.audioContext.resume();
                    }

                    // ============ iOS FIX: Pre-request microphone ============
                    console.log('[Mobile] Pre-requesting microphone...');
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    // Release mic so SDK can use it
                    stream.getTracks().forEach(track => track.stop());
                    // Small delay to ensure mic is released
                    await new Promise(resolve => setTimeout(resolve, 150));

                    // ============ iOS FIX: Audio routing for headphones ============
                    if (navigator.audioSession) {
                        try {
                            navigator.audioSession.type = 'play-and-record';
                            console.log('[Mobile] Set audioSession to play-and-record');
                        } catch (e) {
                            // Not supported on all browsers
                        }
                    }

                    const randomMessage = getRandomFirstMessage();
                    console.log('Starting with message:', randomMessage);

                    conversation = await Conversation.startSession({
                        agentId: agentId,
                        overrides: {
                            agent: {
                                firstMessage: randomMessage
                            }
                        },
                        // Client tools run in the browser and can play sounds!
                        clientTools: {
                            // DJ Soundboard - plays sound effects directly in browser
                            dj_soundboard: async (parameters) => {
                                console.log('üéß CLIENT TOOL: dj_soundboard called with:', parameters);
                                const action = parameters.action || 'list';
                                const sound = parameters.sound || '';

                                if (action === 'list') {
                                    const sounds = Object.keys(DJ_SOUND_LIST);
                                    return `Available sounds: ${sounds.join(', ')}. Use action=play with sound name.`;
                                }

                                if (action === 'play') {
                                    const soundName = sound.toLowerCase().replace(/\s+/g, '_').replace(/-/g, '_');
                                    console.log('üéµ Playing sound:', soundName);

                                    // Play the sound directly
                                    playDJSound(soundName);

                                    const info = DJ_SOUND_LIST[soundName] || { description: soundName };
                                    return `*${info.description || soundName}* üéµ`;
                                }

                                return 'Use action=list or action=play with sound parameter';
                            },
                        },
                        onConnect: () => {
                            console.log('Connected to ElevenLabs');
                            isConnecting = false;
                            callButton.classList.remove('connecting');
                            callButton.classList.add('active');
                            callIcon.textContent = 'üìµ';
                            updateStatus('connected', 'CONNECTED');
                            setMood('happy');
                            blink();
                            setTimeout(() => setMood('neutral'), 1000);
                        },
                        onDisconnect: () => {
                            console.log('Disconnected');
                            conversation = null;
                            callButton.classList.remove('active', 'connecting');
                            callIcon.textContent = 'üìû';
                            updateStatus('disconnected', 'OFFLINE');
                            isSpeaking = false;
                            targetAmplitude = 0;
                            setMood('neutral');
                        },
                        onError: (error) => {
                            console.error('Conversation error:', error);
                            showError(error.message || 'Connection error');
                            setMood('sad');
                            setTimeout(() => setMood('neutral'), 2000);
                        },
                        onModeChange: (mode) => {
                            console.log('Mode changed:', mode);
                            if (mode.mode === 'speaking') {
                                isSpeaking = true;
                                isListening = false;
                                updateStatus('speaking', 'SPEAKING');
                                setMood('neutral');
                                // Duck music when speaking
                                if (typeof duckMusicVolume === 'function') duckMusicVolume(true);
                            } else if (mode.mode === 'listening') {
                                isSpeaking = false;
                                isListening = true;
                                targetAmplitude = 0;
                                updateStatus('listening', 'LISTENING');
                                setMood('listening');
                                // Restore music volume when listening
                                if (typeof duckMusicVolume === 'function') duckMusicVolume(false);
                            } else {
                                isSpeaking = false;
                                isListening = false;
                                // Restore music volume
                                if (typeof duckMusicVolume === 'function') duckMusicVolume(false);
                                targetAmplitude = 0;
                                updateStatus('connected', 'CONNECTED');
                                setMood('neutral');
                            }
                        },
                        onMessage: async (message) => {
                            console.log('Message:', message);

                            // Handle tool responses - ElevenLabs sends these in different formats
                            // Check multiple possible locations for tool name and result
                            const toolName = message.tool_name ||
                                           message.name ||
                                           (message.tool && message.tool.name) ||
                                           (message.data && message.data.tool_name);

                            const toolResult = message.tool_result ||
                                             message.result ||
                                             message.output ||
                                             (message.tool && message.tool.result) ||
                                             (message.data && message.data.result);

                            // Log all messages that might be tool responses
                            if (toolName || message.type?.includes('tool') || message.tool) {
                                console.log('üîß Potential tool response detected:', {
                                    type: message.type,
                                    toolName: toolName,
                                    toolResult: toolResult,
                                    fullMessage: message
                                });
                            }

                            // DJ Soundboard tool - play the sound!
                            if (toolName === 'dj_soundboard') {
                                try {
                                    const toolData = typeof toolResult === 'string'
                                        ? JSON.parse(toolResult)
                                        : toolResult;
                                    console.log('üéß DJ Soundboard response:', toolData);

                                    if (toolData && toolData.action === 'play' && toolData.sound) {
                                        console.log('üéµ Playing DJ sound:', toolData.sound);
                                        playDJSound(toolData.sound);
                                    }
                                } catch (e) {
                                    console.error('Error parsing DJ soundboard result:', e);
                                }
                            }

                            // Music tool - sync playback
                            if (toolName === 'play_music') {
                                console.log('üéµ Music tool called, syncing state...');
                                syncMusicState();
                            }

                            if (message.source === 'user' && message.message) {
                                showTranscription(message.message, true);
                            } else if (message.source === 'ai' && message.message) {
                                showTranscription(message.message, false);

                                // Check for DJ sound effects triggers (fallback for text detection)
                                checkForDJSounds(message.message);

                                // Sync music playback when Pi-Guy mentions playing (fallback)
                                const msg = message.message.toLowerCase();

                                // Track name detection - play specific track when mentioned
                                // ARRAY (not object) so order is guaranteed - check longer/specific matches FIRST
                                const trackKeywords = [
                                    // FoamIt (Moe's Toronto track) - check specific phrases first
                                    ['insulate you right', 'Foam-It-we-insulate-you-right'],
                                    ['foam it insulate', 'Foam-It-we-insulate-you-right'],
                                    ['mississauga', 'Foam-It-we-insulate-you-right'],
                                    ['foam-it', 'Foam-It-we-insulate-you-right'],
                                    ['foamit', 'Foam-It-we-insulate-you-right'],
                                    ['foam it', 'Foam-It-we-insulate-you-right'],
                                    ['toronto', 'Foam-It-we-insulate-you-right'],
                                    ["moe's", 'Foam-It-we-insulate-you-right'],
                                    ['moes', 'Foam-It-we-insulate-you-right'],

                                    // Mrs. Sprayfoam (Karen's Augusta track)
                                    ['mrs. sprayfoam', 'Call-Me-Mrs.Sprayfoam'],
                                    ['mrs sprayfoam', 'Call-Me-Mrs.Sprayfoam'],
                                    ['mrs.sprayfoam', 'Call-Me-Mrs.Sprayfoam'],
                                    ['call me mrs', 'Call-Me-Mrs.Sprayfoam'],
                                    ["karen's", 'Call-Me-Mrs.Sprayfoam'],
                                    ['karens', 'Call-Me-Mrs.Sprayfoam'],
                                    ['augusta', 'Call-Me-Mrs.Sprayfoam'],

                                    // Foam Everything - MUST come after "foam it" variants
                                    ['foam everything', 'Foam-Everything'],

                                    // Hey Diddle Diddle
                                    ['hey diddle diddle', 'Hey-Diddle-Diddle'],
                                    ['diddle diddle', 'Hey-Diddle-Diddle'],
                                    ['hey diddle', 'Hey-Diddle-Diddle'],
                                    ['nursery rhyme', 'Hey-Diddle-Diddle'],

                                    // Polyurethane tracks
                                    ['og polyurethane', 'OG-Polyurthane-gang'],
                                    ['polyurethane gang', 'Polyurethane-Gang'],
                                    ['o.g. poly', 'OG-Polyurthane-gang'],
                                    ['og poly', 'OG-Polyurthane-gang'],
                                    ['poly gang', 'Polyurethane-Gang'],

                                    // Spanish tracks
                                    ['spanish comfy', 'Spanish-ComfyLife'],
                                    ['comfy life', 'Spanish-ComfyLife'],
                                    ['calidez', 'Espuma-Calidez-2'],
                                    ['espuma', 'Espuma-Calidez-2'],
                                    ['latin', 'Spanish-ComfyLife']
                                ];

                                // ===========================================
                                // MUSIC SYNC: Use 'sync' action to get the track Pi-Guy's tool already selected
                                // This prevents race conditions where text detection would select a DIFFERENT track
                                // ===========================================

                                // Detect any music-related keywords to trigger sync
                                const shouldSyncMusic =
                                    // Song change/skip keywords
                                    (msg.includes('next') && (msg.includes('song') || msg.includes('track'))) ||
                                    msg.includes('switching') || msg.includes('change it up') ||
                                    msg.includes('different song') || msg.includes("i'm changing") ||
                                    msg.includes('changing it') || msg.includes('let me change') ||
                                    // Play keywords
                                    msg.includes('spinning') || msg.includes("let's go") ||
                                    msg.includes('playing') || msg.includes('next up') ||
                                    msg.includes('here we go') || msg.includes('coming up') ||
                                    msg.includes('dropping') || msg.includes('fire up');

                                if (shouldSyncMusic) {
                                    // Use SYNC action - gets the reserved track WITHOUT selecting a new one
                                    console.log('üéµ Music detected, syncing with server (NOT selecting new track)...');
                                    syncMusicWithServer();
                                } else if (msg.includes('stopped') || msg.includes('stopping') ||
                                    msg.includes('kill the music') || msg.includes('cut the music')) {
                                    stopMusicPlayback();
                                } else if (msg.includes('pausing') || msg.includes('paused') ||
                                    msg.includes('hold up') || msg.includes('one sec')) {
                                    pauseMusicPlayback();
                                }

                                // Track agent response for usage limits
                                if (clerkUser) {
                                    try {
                                        const resp = await fetch(`${VISION_SERVER_URL}/api/usage/${clerkUser.id}/increment`, { method: 'POST' });
                                        const usage = await resp.json();
                                        console.log('Usage:', usage);
                                        if (usage.remaining <= 5) {
                                            console.warn(`Warning: Only ${usage.remaining} responses remaining this month`);
                                        }
                                    } catch (e) {
                                        console.error('Usage tracking error:', e);
                                    }
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('Failed to start conversation:', error);
                    isConnecting = false;
                    callButton.classList.remove('connecting');
                    callIcon.textContent = 'üìû';
                    updateStatus('disconnected', 'OFFLINE');

                    // Better error messages for mobile
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    if (error.name === 'NotAllowedError') {
                        if (isIOS) {
                            showError('Mic blocked. Go to Settings > Safari > Microphone to allow.');
                        } else {
                            showError('Microphone access denied. Please allow microphone access.');
                        }
                    } else if (error.name === 'NotFoundError') {
                        showError('No microphone found. Please connect a microphone.');
                    } else if (error.name === 'NotReadableError') {
                        showError('Microphone in use by another app. Close other apps and try again.');
                    } else {
                        showError(error.message || 'Failed to connect');
                    }
                    setMood('sad');
                    setTimeout(() => setMood('neutral'), 2000);
                }
            }
        };

        // ===== RANDOM LOOKING BEHAVIOR =====
        let lastMouseMove = Date.now();
        let randomLookInterval;

        function randomLook() {
            // Only do random look if mouse hasn't moved recently (2 seconds)
            if (Date.now() - lastMouseMove > 2000 && currentMood !== 'thinking') {
                const x = window.innerWidth * (0.2 + Math.random() * 0.6);
                const y = window.innerHeight * (0.15 + Math.random() * 0.5);
                updateEyePosition(x, y);
            }
        }

        // Random look every 1.5-4 seconds
        function scheduleRandomLook() {
            const delay = 1500 + Math.random() * 2500;
            setTimeout(() => {
                randomLook();
                scheduleRandomLook();
            }, delay);
        }

        scheduleRandomLook();

        // Random expressions when idle
        function scheduleRandomExpression() {
            const delay = 5000 + Math.random() * 10000; // Every 5-15 seconds
            setTimeout(() => {
                // Only change expression if not in conversation and not already in a mood
                if (!conversation && currentMood === 'neutral') {
                    const expressions = ['angry', 'angry', 'angry', 'thinking', 'happy'];
                    const randomExpr = expressions[Math.floor(Math.random() * expressions.length)];
                    setMood(randomExpr);

                    // Return to neutral after a short time
                    setTimeout(() => {
                        if (!conversation) setMood('neutral');
                    }, 1000 + Math.random() * 2000);
                }
                scheduleRandomExpression();
            }, delay);
        }

        scheduleRandomExpression();

        // Track mouse movement
        document.addEventListener('mousemove', (e) => {
            lastMouseMove = Date.now();
        });

        // ===== CAMERA CONTROL =====
        window.toggleCamera = async function() {
            if (cameraStream) {
                // Stop camera
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
                cameraVideo.srcObject = null;
                cameraButton.classList.remove('active');
                currentIdentity = null;

                // Stop sending frames
                if (frameInterval) {
                    clearInterval(frameInterval);
                    frameInterval = null;
                }
                console.log('Camera disabled');
            } else {
                // Start camera
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: 640, height: 480 }
                    });
                    cameraVideo.srcObject = cameraStream;
                    cameraButton.classList.add('active');
                    console.log('Camera enabled');

                    // Wait for video to be ready, then identify face
                    cameraVideo.onloadedmetadata = async () => {
                        // Give it a moment to get a good frame
                        setTimeout(async () => {
                            await identifyFace();
                        }, 500);
                    };

                    // Start sending frames to server every 2 seconds
                    frameInterval = setInterval(sendFrameToServer, 2000);
                } catch (error) {
                    console.error('Camera error:', error);
                    showError('Camera access denied');
                }
            }
        };

        // Identify the face in the camera
        async function identifyFace() {
            const frame = captureFrame();
            if (!frame) {
                console.log('No frame available for identification');
                return;
            }

            try {
                console.log('Attempting face identification...');
                const response = await fetch(`${VISION_SERVER_URL}/api/identify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: frame })
                });
                const data = await response.json();
                currentIdentity = data;
                console.log('Face identification result:', data);

                if (data.name !== 'unknown') {
                    showFaceNotification(`Recognized: ${data.name} (${data.confidence}%)`);
                    setTimeout(hideFaceNotification, 3000);
                }
            } catch (error) {
                console.error('Face identification error:', error);
            }
        }

        // Re-identify periodically while camera is on (every 10 seconds)
        setInterval(() => {
            if (cameraStream && !conversation) {
                identifyFace();
            }
        }, 10000);

        function captureFrame() {
            if (!cameraStream || !cameraVideo.videoWidth) return null;

            captureCanvas.width = cameraVideo.videoWidth;
            captureCanvas.height = cameraVideo.videoHeight;
            const ctx = captureCanvas.getContext('2d');
            ctx.drawImage(cameraVideo, 0, 0);
            return captureCanvas.toDataURL('image/jpeg', 0.8);
        }

        async function sendFrameToServer() {
            const frame = captureFrame();
            if (!frame) return;

            try {
                await fetch(`${VISION_SERVER_URL}/api/frame`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: frame })
                });
            } catch (error) {
                console.error('Failed to send frame:', error);
            }
        }

        // Expose for debugging
        window.captureAndDescribe = async function() {
            const frame = captureFrame();
            if (!frame) {
                console.log('No camera frame available');
                return;
            }

            try {
                const response = await fetch(`${VISION_SERVER_URL}/api/vision`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: frame })
                });
                const data = await response.json();
                console.log('Vision response:', data.response);
                return data.response;
            } catch (error) {
                console.error('Vision error:', error);
            }
        };

        // Save current face to database
        window.saveFace = async function(name) {
            if (!name) {
                console.log('Usage: saveFace("Name")');
                return;
            }
            const frame = captureFrame();
            if (!frame) {
                console.log('No camera frame available - turn on camera first');
                return;
            }

            try {
                const response = await fetch(`${VISION_SERVER_URL}/api/faces/${encodeURIComponent(name)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: frame })
                });
                const data = await response.json();
                console.log('Save face result:', data);
                return data;
            } catch (error) {
                console.error('Save face error:', error);
            }
        };

        // List known faces
        window.listFaces = async function() {
            try {
                const response = await fetch(`${VISION_SERVER_URL}/api/faces`);
                const data = await response.json();
                console.log('Known faces:', data);
                return data;
            } catch (error) {
                console.error('List faces error:', error);
            }
        };

        // Get current identity
        window.getIdentity = function() {
            console.log('Current identity:', currentIdentity);
            return currentIdentity;
        };

        // ===== WAKE WORD DETECTION =====
        let wakeWordRecognition = null;
        let isWakeWordListening = false;
        let wakeWordEnabled = false;
        let wakeWordTriggered = false;  // Prevents multiple triggers
        const WAKE_WORDS = [
            // Pi Guy variations
            'pi guy', 'hey pi guy', 'pie guy', 'hey pie guy',
            // AI Guy variations
            'ai guy', 'hey ai guy', 'a i guy', 'hey ai',
            // Foam Bot variations (for foam people)
            'foam bot', 'hey foam bot', 'foambot', 'phone bot', 'hey phone bot',
            // Other common misheard variations
            'hi guy', 'hey hi guy', 'my guy', 'hey my guy',
            'five guy', 'fly guy', 'by guy', 'buy guy',
            'fi guy', 'fy guy', 'psy guy', 'sci guy'
        ];

        window.toggleWakeWord = async function() {
            if (wakeWordEnabled) {
                stopWakeWordListener();
                wakeWordEnabled = false;
                wakeButton.classList.remove('active');
                wakeIcon.textContent = 'üé§';
                updateStatus('disconnected', 'OFFLINE');
                console.log('Wake word disabled');
            } else {
                // Request mic permission first
                try {
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                } catch (e) {
                    showError('Microphone permission required for voice activation');
                    return;
                }

                const started = startWakeWordListener();
                if (started !== false) {
                    wakeWordEnabled = true;
                    wakeButton.classList.add('active');
                    wakeIcon.textContent = 'üëÇ';
                    updateStatus('listening', 'LISTENING FOR "PIE GUY"');
                    console.log('Wake word enabled - say "Pie Guy" or "Hey Pie Guy"');
                }
            }
        };

        function startWakeWordListener() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('Wake word not supported - Speech Recognition API not available');
                showError('Voice activation not supported in this browser');
                return false;
            }

            // Reset trigger flag when starting fresh
            wakeWordTriggered = false;

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            wakeWordRecognition = new SpeechRecognition();
            wakeWordRecognition.continuous = true;
            wakeWordRecognition.interimResults = true;
            wakeWordRecognition.lang = 'en-US';

            wakeWordRecognition.onresult = (event) => {
                // Don't listen for wake word while in conversation, connecting, or already triggered
                if (conversation || isConnecting || wakeWordTriggered) return;

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript.toLowerCase().trim();
                    console.log('Heard:', transcript);

                    // Check if any wake word is in the transcript
                    for (const wakeWord of WAKE_WORDS) {
                        if (transcript.includes(wakeWord)) {
                            console.log('Wake word detected!', wakeWord);
                            // Set flag immediately to prevent any more triggers
                            wakeWordTriggered = true;
                            // Stop wake word listener and give mic time to release before starting conversation
                            stopWakeWordListener();
                            setTimeout(() => {
                                toggleConversation();
                            }, 800);
                            return;
                        }
                    }
                }
            };

            wakeWordRecognition.onend = () => {
                // Restart if wake word mode is enabled and not in a conversation or connecting
                if (wakeWordEnabled && !conversation && !isConnecting) {
                    setTimeout(() => {
                        if (wakeWordEnabled && !conversation && !isConnecting && wakeWordRecognition) {
                            try {
                                wakeWordRecognition.start();
                            } catch (e) {
                                console.log('Could not restart wake word:', e);
                            }
                        }
                    }, 100);
                }
            };

            wakeWordRecognition.onerror = (event) => {
                console.log('Wake word error:', event.error);
                if (event.error === 'not-allowed') {
                    showError('Microphone permission denied');
                    wakeWordEnabled = false;
                    wakeButton.classList.remove('active');
                    wakeIcon.textContent = 'üé§';
                }
            };

            try {
                wakeWordRecognition.start();
                isWakeWordListening = true;
                return true;
            } catch (e) {
                console.log('Could not start wake word listener:', e);
                showError('Could not start voice activation');
                return false;
            }
        }

        function stopWakeWordListener() {
            isWakeWordListening = false;
            if (wakeWordRecognition) {
                try {
                    wakeWordRecognition.stop();
                } catch (e) {}
                wakeWordRecognition = null;
            }
        }

        // Restart wake word listener when conversation ends (if enabled)
        const originalToggleConversation = window.toggleConversation;
        window.toggleConversation = async function() {
            const wasInConversation = !!conversation;
            await originalToggleConversation();

            // If conversation just ended and wake word was enabled, restart it
            if (wasInConversation && !conversation && wakeWordEnabled) {
                setTimeout(() => {
                    startWakeWordListener();
                }, 1000);
            }
        };

        // ===== KEYBOARD SHORTCUTS =====
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Enter') {
                e.preventDefault();
                toggleConversation();
            } else if (e.key === 'Escape' && conversation) {
                toggleConversation();
            }
        });

        // Enter key in agent ID input
        agentIdInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                saveAgentId();
            }
        });

        // ===== EXPOSE FOR DEBUGGING =====
        window.piGuy = {
            setMood,
            blink,
            getConversation: () => conversation,
            setAgentId: (id) => {
                agentId = id;
                localStorage.setItem('piGuyAgentId', id);
            }
        };

        // ===== CLERK AUTHENTICATION =====
        let clerkUser = null;

        async function initClerk() {
            try {
                // Wait for Clerk to load
                await window.Clerk.load();

                const userButtonDiv = document.getElementById('user-button');
                const signInButtonDiv = document.getElementById('sign-in-button');
                const loginBtn = document.getElementById('login-btn');
                const clerkModal = document.getElementById('clerk-modal');
                const signInContainer = document.getElementById('sign-in-container');

                if (window.Clerk.user) {
                    // User is signed in
                    clerkUser = window.Clerk.user;
                    console.log('Signed in as:', clerkUser.primaryEmailAddress?.emailAddress || clerkUser.id);
                    signInButtonDiv.style.display = 'none';
                    window.Clerk.mountUserButton(userButtonDiv);
                } else {
                    // User is not signed in
                    signInButtonDiv.style.display = 'block';

                    loginBtn.addEventListener('click', () => {
                        clerkModal.style.display = 'flex';
                        window.Clerk.mountSignIn(signInContainer);
                    });

                    // Close modal when clicking outside
                    clerkModal.addEventListener('click', (e) => {
                        if (e.target === clerkModal) {
                            clerkModal.style.display = 'none';
                            window.Clerk.unmountSignIn(signInContainer);
                        }
                    });
                }

                // Listen for auth changes
                window.Clerk.addListener(({ user }) => {
                    if (user) {
                        clerkUser = user;
                        clerkModal.style.display = 'none';
                        signInButtonDiv.style.display = 'none';
                        window.Clerk.mountUserButton(userButtonDiv);
                        console.log('User signed in:', user.primaryEmailAddress?.emailAddress);
                        // Refresh community panel if open
                        if (typeof updateMyFaceSection === 'function') {
                            loadCommunityList().then(() => updateMyFaceSection());
                        }
                    } else {
                        clerkUser = null;
                        signInButtonDiv.style.display = 'block';
                        // Hide my face section when logged out
                        if (typeof updateMyFaceSection === 'function') {
                            updateMyFaceSection();
                        }
                    }
                });

            } catch (error) {
                console.error('Clerk initialization error:', error);
            }
        }

        // Initialize Clerk when script loads
        if (window.Clerk) {
            initClerk();
        } else {
            // Wait for Clerk script to load
            document.querySelector('script[src*="clerk"]').addEventListener('load', initClerk);
        }

        // Helper to check if user is logged in
        window.isLoggedIn = () => !!clerkUser;
        window.getUser = () => clerkUser;

        // ===== MOBILE DEBUG HELPER =====
        window.mobileDebug = function() {
            const info = {
                userAgent: navigator.userAgent,
                isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
                isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                isAndroid: /Android/.test(navigator.userAgent),
                audioContextState: window.audioContext?.state || 'not created',
                audioUnlocked: window.isAudioUnlocked?.() || false,
                audioContextSupport: !!window.AudioContext,
                mediaDevicesSupport: !!navigator.mediaDevices,
                getUserMediaSupport: !!navigator.mediaDevices?.getUserMedia,
                webRTCSupport: !!window.RTCPeerConnection,
                audioSessionSupport: !!navigator.audioSession,
                screenWidth: window.innerWidth,
                screenHeight: window.innerHeight,
                touchSupport: 'ontouchstart' in window
            };
            console.log('=== Mobile Debug Info ===');
            console.table(info);
            return info;
        };

        // Auto-log debug info if ?debug in URL
        if (location.search.includes('debug')) {
            document.addEventListener('DOMContentLoaded', () => {
                window.mobileDebug();
            });
        }

        // Show hint on iOS first visit
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        if (isIOS && !sessionStorage.getItem('iosAudioHint')) {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => {
                    showTranscription('Tap anywhere to enable audio', false);
                    setTimeout(hideTranscription, 3000);
                    sessionStorage.setItem('iosAudioHint', 'true');
                }, 1000);
            });
        }

        // ===== DJ PI-GUY MUSIC SYSTEM =====

        // Initialize music player
        musicPlayer.volume = musicVolume;
        let djTransitionTriggered = false;  // Prevent multiple triggers per track
        let nextTrackQueued = null;         // Track queued for smooth transition
        const DJ_INTRO_TIME = 12;           // Seconds before end to trigger DJ intro

        // Monitor playback for DJ transitions
        musicPlayer.addEventListener('timeupdate', async () => {
            if (!musicPlaying || !currentTrack) return;

            const duration = musicPlayer.duration || currentTrack.duration_seconds || 120;
            const currentTime = musicPlayer.currentTime;
            const remaining = duration - currentTime;

            // Trigger DJ intro when ~12 seconds remain (enough time to intro next song)
            if (remaining <= DJ_INTRO_TIME && remaining > (DJ_INTRO_TIME - 1) && !djTransitionTriggered && isConversationActive) {
                djTransitionTriggered = true;
                console.log(`üéôÔ∏è DJ Transition: ${remaining.toFixed(1)}s remaining - triggering next song intro`);

                // Signal the server that a transition is needed
                try {
                    const response = await fetch(`${VISION_SERVER_URL}/api/music/transition`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ remaining_seconds: remaining })
                    });
                    const data = await response.json();
                    if (data.next_track) {
                        nextTrackQueued = data.next_track;
                        console.log('üéµ Next up:', data.next_track.title || data.next_track.name);
                        console.log('üìù Transition queued on server');

                        // Dispatch event for any listeners
                        window.dispatchEvent(new CustomEvent('dj-transition', {
                            detail: {
                                nextTrack: data.next_track,
                                remainingSeconds: remaining
                            }
                        }));
                    }
                } catch (err) {
                    console.error('Failed to queue transition:', err);
                }
            }
        });

        // When track ends, play the queued next track
        musicPlayer.addEventListener('ended', async () => {
            djTransitionTriggered = false;  // Reset for next track

            if (nextTrackQueued) {
                // Play the pre-queued track
                currentTrack = nextTrackQueued;
                trackName.textContent = nextTrackQueued.title || nextTrackQueued.name;
                musicPlayer.src = `${VISION_SERVER_URL}/music/${nextTrackQueued.filename}`;
                musicPlayer.play();
                nextTrackQueued = null;
                console.log('üéµ Playing queued track:', currentTrack.title || currentTrack.name);
            } else {
                // No queued track, fetch next
                musicControl('next');
            }
        });

        // Duck music volume when Pi-Guy speaks
        function duckMusicVolume(duck) {
            if (musicPlaying) {
                const targetVol = duck ? musicVolume * 0.3 : musicVolume;
                musicPlayer.volume = targetVol;
            }
        }

        // Toggle music play/pause from button
        window.toggleMusic = async function() {
            if (musicPlaying) {
                musicPlayer.pause();
                musicPlaying = false;
                musicButton.classList.remove('playing');
                playPauseBtn.textContent = '‚ñ∂';
                nowPlaying.classList.remove('visible');
            } else {
                // If we have a track, resume. Otherwise fetch random
                if (currentTrack) {
                    musicPlayer.play();
                    musicPlaying = true;
                    musicButton.classList.add('playing');
                    playPauseBtn.textContent = '‚è∏';
                    nowPlaying.classList.add('visible');
                } else {
                    // Fetch and play a random track
                    await playMusicFromServer('play');
                }
            }
        };

        // Control music from now-playing panel
        window.musicControl = async function(action) {
            switch(action) {
                case 'toggle':
                    toggleMusic();
                    break;
                case 'next':
                    await playMusicFromServer('skip');
                    break;
                case 'prev':
                    // Restart current track or go to previous (just restart for now)
                    if (musicPlayer.currentTime > 3) {
                        musicPlayer.currentTime = 0;
                    } else {
                        await playMusicFromServer('skip');  // No real prev, just skip
                    }
                    break;
            }
        };

        // Set volume from slider
        window.setMusicVolume = function(value) {
            musicVolume = value / 100;
            musicPlayer.volume = isSpeaking ? musicVolume * 0.3 : musicVolume;
        };

        // Play music from server API
        async function playMusicFromServer(action, track = '') {
            try {
                let url = `${VISION_SERVER_URL}/api/music?action=${action}`;
                if (track) url += `&track=${encodeURIComponent(track)}`;

                const response = await fetch(url);
                const data = await response.json();

                if (data.action === 'play' && data.url) {
                    currentTrack = data.track;
                    trackName.textContent = data.track.name;
                    musicPlayer.src = `${VISION_SERVER_URL}${data.url}`;
                    musicPlayer.play();
                    musicPlaying = true;
                    musicButton.classList.add('playing');
                    playPauseBtn.textContent = '‚è∏';
                    nowPlaying.classList.add('visible');

                    // Duck if speaking
                    if (isSpeaking) duckMusicVolume(true);
                } else if (data.action === 'pause') {
                    musicPlayer.pause();
                    musicPlaying = false;
                    playPauseBtn.textContent = '‚ñ∂';
                } else if (data.action === 'resume') {
                    musicPlayer.play();
                    musicPlaying = true;
                    playPauseBtn.textContent = '‚è∏';
                } else if (data.action === 'stop') {
                    musicPlayer.pause();
                    musicPlayer.currentTime = 0;
                    musicPlaying = false;
                    currentTrack = null;
                    musicButton.classList.remove('playing');
                    nowPlaying.classList.remove('visible');
                } else if (data.action === 'volume' && data.volume !== undefined) {
                    musicVolume = data.volume / 100;
                    musicPlayer.volume = musicVolume;
                    volumeSlider.value = data.volume;
                }

                return data;
            } catch (error) {
                console.error('Music API error:', error);
                return { action: 'error', response: 'Failed to communicate with music server' };
            }
        }

        // Handle music commands from ElevenLabs tool responses
        // This is called when Pi-Guy's tool returns music data
        window.handleMusicCommand = function(musicData) {
            if (!musicData || !musicData.action) return;

            switch(musicData.action) {
                case 'play':
                    if (musicData.url) {
                        currentTrack = musicData.track;
                        trackName.textContent = musicData.track?.name || 'Unknown';
                        musicPlayer.src = `${VISION_SERVER_URL}${musicData.url}`;
                        musicPlayer.play();
                        musicPlaying = true;
                        musicButton.classList.add('playing');
                        playPauseBtn.textContent = '‚è∏';
                        nowPlaying.classList.add('visible');
                    }
                    break;
                case 'pause':
                    musicPlayer.pause();
                    musicPlaying = false;
                    playPauseBtn.textContent = '‚ñ∂';
                    break;
                case 'resume':
                    musicPlayer.play();
                    musicPlaying = true;
                    playPauseBtn.textContent = '‚è∏';
                    break;
                case 'stop':
                    musicPlayer.pause();
                    musicPlayer.currentTime = 0;
                    musicPlaying = false;
                    currentTrack = null;
                    musicButton.classList.remove('playing');
                    nowPlaying.classList.remove('visible');
                    break;
                case 'volume':
                    if (musicData.volume !== undefined) {
                        musicVolume = musicData.volume / 100;
                        musicPlayer.volume = musicVolume;
                        volumeSlider.value = musicData.volume;
                    }
                    break;
            }
        };

        // Sync music state with server (called when Pi-Guy says he's playing something)
        async function syncMusicState() {
            try {
                const response = await fetch(`${VISION_SERVER_URL}/api/music?action=status`);
                const data = await response.json();
                console.log('Music state from server:', data);

                if (data.playing && data.track) {
                    currentTrack = data.track;
                    trackName.textContent = data.track.name;
                    musicPlayer.src = `${VISION_SERVER_URL}/music/${data.track.filename}`;
                    musicPlayer.volume = isSpeaking ? (data.volume / 100) * 0.3 : data.volume / 100;
                    musicPlayer.play();
                    musicPlaying = true;
                    musicButton.classList.add('playing');
                    playPauseBtn.textContent = '‚è∏';
                    nowPlaying.classList.add('visible');
                    volumeSlider.value = data.volume;
                    console.log('Music started:', data.track.name);
                }
            } catch (error) {
                console.error('Failed to sync music state:', error);
            }
        }

        // Stop music playback
        function stopMusicPlayback() {
            musicPlayer.pause();
            musicPlayer.currentTime = 0;
            musicPlaying = false;
            currentTrack = null;
            musicButton.classList.remove('playing');
            nowPlaying.classList.remove('visible');
            console.log('Music stopped');
        }

        // Pause music playback
        function pauseMusicPlayback() {
            musicPlayer.pause();
            musicPlaying = false;
            playPauseBtn.textContent = '‚ñ∂';
            console.log('Music paused');
        }

        // =============================================
        // SYNC MUSIC WITH SERVER - Prevents race conditions
        // Uses 'sync' action which NEVER selects a new track
        // Only returns the track that Pi-Guy's tool already reserved
        // =============================================
        let lastSyncTime = 0;
        let lastSyncedTrack = null;
        const SYNC_DEBOUNCE_MS = 2000;  // Ignore sync calls within 2 seconds of each other

        async function syncMusicWithServer() {
            const now = Date.now();

            // Debounce: Ignore if we synced recently
            if (now - lastSyncTime < SYNC_DEBOUNCE_MS) {
                console.log('üéµ Sync debounced (too soon since last sync)');
                return;
            }
            lastSyncTime = now;

            try {
                console.log('üéµ Syncing with server (action=sync)...');
                const response = await fetch(`${VISION_SERVER_URL}/api/music?action=sync`);
                const data = await response.json();
                console.log('üéµ Sync response:', data);

                if (data.action === 'play' && data.track && data.url) {
                    // Check if this is a different track than what's playing
                    if (currentTrack && currentTrack.filename === data.track.filename && musicPlaying) {
                        console.log('üéµ Already playing this track, skipping');
                        return;
                    }

                    // Check if we just synced to this same track
                    if (lastSyncedTrack === data.track.filename) {
                        console.log('üéµ Just synced to this track, skipping duplicate');
                        return;
                    }
                    lastSyncedTrack = data.track.filename;

                    // Play the track!
                    currentTrack = data.track;
                    trackName.textContent = data.track.title || data.track.name;
                    musicPlayer.src = `${VISION_SERVER_URL}${data.url}`;
                    musicPlayer.volume = isSpeaking ? musicVolume * 0.3 : musicVolume;
                    musicPlayer.play();
                    musicPlaying = true;
                    musicButton.classList.add('playing');
                    playPauseBtn.textContent = '‚è∏';
                    nowPlaying.classList.add('visible');
                    console.log('üéµ Now playing (synced):', data.track.title || data.track.name);

                    // Confirm playback to clear the reservation
                    if (data.reservation_id) {
                        fetch(`${VISION_SERVER_URL}/api/music?action=confirm&reservation_id=${data.reservation_id}`)
                            .then(r => r.json())
                            .then(d => console.log('üéµ Reservation confirmed:', d.response))
                            .catch(e => console.error('üéµ Confirm failed:', e));
                    }
                } else if (data.action === 'none') {
                    console.log('üéµ No track to sync (Pi-Guy hasnt selected one yet)');
                }
            } catch (error) {
                console.error('üéµ Sync failed:', error);
            }
        }

        // Clear last synced track after 30 seconds (allow re-sync to same track later)
        setInterval(() => { lastSyncedTrack = null; }, 30000);

        // Expose for console testing
        window.playMusic = (track) => playMusicFromServer('play', track);
        window.stopMusic = () => playMusicFromServer('stop');
        window.listMusic = async () => {
            const data = await playMusicFromServer('list');
            console.log('Available tracks:', data.tracks);
            return data;
        };
        window.syncMusicState = syncMusicState;
        window.syncMusicWithServer = syncMusicWithServer;  // New sync function

        // ===== DJ SOUNDBOARD =====
        // Sound effects player for DJ-FoamBot
        // Create new Audio for each sound so they can overlap
        // Pre-loaded sound cache for instant playback
        const djSoundCache = {};

        // Preload a sound for faster playback
        async function preloadDJSound(soundName) {
            const url = `${VISION_SERVER_URL}/sounds/${soundName}.mp3`;
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                djSoundCache[soundName] = URL.createObjectURL(blob);
                console.log('üéß Preloaded DJ sound:', soundName);
            } catch (e) {
                console.warn('Failed to preload sound:', soundName, e);
            }
        }

        // Preload common sounds on page load
        ['air_horn', 'scratch_long', 'crowd_cheer', 'rewind', 'yeah', 'laser'].forEach(s => {
            setTimeout(() => preloadDJSound(s), 1000);
        });

        async function playDJSound(soundName) {
            try {
                console.log('üéß playDJSound called with:', soundName);

                // Create new audio element for this sound (allows overlapping)
                const player = new Audio();
                player.volume = 0.9;  // 90% volume for sound effects

                // Use cached blob URL if available, otherwise fetch with cache-busting
                let url;
                if (djSoundCache[soundName]) {
                    url = djSoundCache[soundName];
                    console.log('üéµ Using cached sound:', soundName);
                } else {
                    // Add cache-busting timestamp to get fresh sounds
                    const timestamp = Date.now();
                    url = `${VISION_SERVER_URL}/sounds/${soundName}.mp3?t=${timestamp}`;
                    console.log('üéµ Loading sound from:', url);
                }

                player.src = url;

                // Wait for audio to be ready before playing
                await new Promise((resolve, reject) => {
                    player.oncanplaythrough = resolve;
                    player.onerror = reject;
                    player.load();
                    // Timeout fallback
                    setTimeout(resolve, 500);
                });

                // Play the sound
                const playPromise = player.play();
                if (playPromise) {
                    playPromise.then(() => {
                        console.log('üéµ DJ Sound playing:', soundName);
                    }).catch(err => {
                        console.error('üéµ DJ Sound play error:', err);
                        // Try again without waiting - autoplay policy issue
                        console.log('üéµ Attempting silent unlock and retry...');
                    });
                }

                return { sound: soundName, url: url };
            } catch (error) {
                console.error('DJ Sound error:', error);
                return null;
            }
        }

        // Detect DJ sound triggers in Pi-Guy's messages
        // Plays ALL sounds mentioned, not just the first one!
        function checkForDJSounds(message) {
            const msg = message.toLowerCase();

            // Direct sound effect mentions (when Pi-Guy says he's playing a sound)
            // Available sounds: air_horn, bruh, crowd_cheer, crowd_hype, gunshot,
            // impact, laser, lets_go, record_stop, rewind, sad_trombone, scratch_long, yeah
            const soundTriggers = {
                // Air horn - classic DJ hype sound
                'air horn': 'air_horn',
                'airhorn': 'air_horn',
                'triple horn': 'air_horn',
                'horn': 'air_horn',
                'bwaaah': 'air_horn',
                'bwaaa': 'air_horn',

                // Scratch - DJ turntable
                'scratch': 'scratch_long',
                'wicka': 'scratch_long',
                'wikka': 'scratch_long',
                'scratching': 'scratch_long',

                // Rewind - pull up selecta!
                'rewind': 'rewind',
                'pull up': 'rewind',
                'pull it back': 'rewind',
                'back it up': 'rewind',
                'selecta': 'rewind',
                'wheel up': 'rewind',

                // Record stop
                'record stop': 'record_stop',
                'stop the record': 'record_stop',
                'needle scratch': 'record_stop',

                // Crowd sounds
                'crowd goes wild': 'crowd_hype',
                'crowd hype': 'crowd_hype',
                'hype': 'crowd_hype',
                'going crazy': 'crowd_hype',
                'lose their minds': 'crowd_hype',
                'crowd cheer': 'crowd_cheer',
                'applause': 'crowd_cheer',
                'cheering': 'crowd_cheer',
                'clapping': 'crowd_cheer',
                'give it up': 'crowd_cheer',

                // Laser/sci-fi
                'laser': 'laser',
                'pew pew': 'laser',
                'pew': 'laser',
                'zap': 'laser',
                'beam': 'laser',

                // Gunshot/bang
                'gunshot': 'gunshot',
                'gun shot': 'gunshot',
                'bang': 'gunshot',
                'shots': 'gunshot',
                'pow': 'gunshot',

                // Impact/hit
                'impact': 'impact',
                'punch': 'impact',
                'boom': 'impact',
                'hit': 'impact',
                'drop': 'impact',
                'thud': 'impact',

                // Vocal hype
                'yeah': 'yeah',
                'yeahhh': 'yeah',
                'yeeah': 'yeah',
                'lets go': 'lets_go',
                "let's go": 'lets_go',
                "let's gooo": 'lets_go',
                'here we go': 'lets_go',

                // Comedy/fail
                'bruh': 'bruh',
                'bruhhh': 'bruh',
                'bro': 'bruh',
                'sad trombone': 'sad_trombone',
                'womp womp': 'sad_trombone',
                'wah wah': 'sad_trombone',
                'fail': 'sad_trombone',
                'that sucks': 'sad_trombone',
                'price is wrong': 'sad_trombone'
            };

            // Find ALL sounds mentioned in the message
            const soundsToPlay = [];
            const alreadyQueued = new Set();

            for (const [trigger, sound] of Object.entries(soundTriggers)) {
                if (msg.includes(trigger) && !alreadyQueued.has(sound)) {
                    soundsToPlay.push({ trigger, sound });
                    alreadyQueued.add(sound);
                }
            }

            // Play all sounds immediately (no delay - realtime!)
            soundsToPlay.forEach((item) => {
                console.log('üéß DJ Sound trigger detected:', item.trigger, '->', item.sound);
                playDJSound(item.sound);
            });

            return soundsToPlay.length > 0 ? soundsToPlay.map(s => s.sound) : null;
        }

        // Expose for console debugging
        window.playDJSound = playDJSound;
        window.checkForDJSounds = checkForDJSounds;

        // ===== COMMUNITY PANEL =====
        const communityToggle = document.getElementById('community-toggle');
        const communityContent = document.getElementById('community-content');
        const communityList = document.getElementById('community-list');
        const myFaceSection = document.getElementById('my-face-section');
        const myFaceInfo = document.getElementById('my-face-info');
        const myFacePhotos = document.getElementById('my-face-photos');
        const registerName = document.getElementById('register-name');
        const captureBtn = document.getElementById('capture-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const fileUpload = document.getElementById('file-upload');
        const photoPreview = document.getElementById('photo-preview');
        const registerStatus = document.getElementById('register-status');

        const MAX_PHOTOS_PER_USER = 10;
        let pendingPhotos = []; // Photos waiting to be saved
        let facesData = {}; // Store face data from server
        let myFaceName = null; // The name registered to current user

        // Toggle panel
        communityToggle.addEventListener('click', () => {
            communityContent.classList.toggle('open');
            if (communityContent.classList.contains('open')) {
                loadCommunityList();
                updateMyFaceSection();
            }
        });

        // Close button
        document.getElementById('community-close').addEventListener('click', () => {
            communityContent.classList.remove('open');
        });

        // Load list of registered faces - simple text with confidence
        async function loadCommunityList() {
            try {
                const response = await fetch(`${VISION_SERVER_URL}/api/faces`);
                facesData = await response.json();

                communityList.innerHTML = '';
                const names = Object.keys(facesData).sort();

                if (names.length === 0) {
                    communityList.innerHTML = '<li style="color: var(--blue-dim);">No faces registered yet</li>';
                    return;
                }

                // Get current recognition results if available
                const confidenceMap = {};
                if (currentIdentity && currentIdentity.name !== 'unknown') {
                    confidenceMap[currentIdentity.name] = currentIdentity.confidence;
                }

                names.forEach(name => {
                    const li = document.createElement('li');
                    const confidence = confidenceMap[name];

                    let confidenceHtml = '';
                    if (confidence !== undefined) {
                        let confidenceClass = 'low';
                        if (confidence >= 70) confidenceClass = 'high';
                        else if (confidence >= 40) confidenceClass = 'medium';
                        confidenceHtml = `<span class="confidence ${confidenceClass}">${confidence}%</span>`;
                    }

                    li.innerHTML = `<span>${name}</span>${confidenceHtml}`;
                    communityList.appendChild(li);
                });
            } catch (error) {
                console.error('Failed to load faces:', error);
                communityList.innerHTML = '<li style="color: var(--red);">Failed to load</li>';
            }
        }

        // Update My Face section based on login status
        function updateMyFaceSection() {
            if (!clerkUser) {
                myFaceSection.style.display = 'none';
                return;
            }

            myFaceSection.style.display = 'block';

            // Find if user has a registered face
            myFaceName = null;
            for (const [name, data] of Object.entries(facesData)) {
                if (data.owner_id === clerkUser.id) {
                    myFaceName = name;
                    break;
                }
            }

            if (myFaceName) {
                const faceData = facesData[myFaceName];
                myFaceInfo.textContent = `Registered as: ${myFaceName} (${faceData.photo_count}/${MAX_PHOTOS_PER_USER} photos)`;
                registerName.value = myFaceName;
                registerName.disabled = true; // Can't change name once registered

                // Show user's photos with delete buttons
                myFacePhotos.innerHTML = faceData.photos.map(photo => `
                    <div class="photo-item">
                        <img src="${VISION_SERVER_URL}/known_faces/${encodeURIComponent(myFaceName)}/${photo}"
                             alt="${photo}"
                             onerror="this.style.display='none'" />
                        <button class="delete-photo" onclick="deleteMyPhoto('${photo}')" title="Delete">‚úï</button>
                    </div>
                `).join('');
            } else {
                myFaceInfo.textContent = 'Add photos to register your face';
                registerName.value = '';
                registerName.disabled = false;
                myFacePhotos.innerHTML = '';
            }
        }

        // Delete a single photo
        window.deleteMyPhoto = async function(filename) {
            if (!clerkUser || !myFaceName) return;

            if (!confirm(`Delete this photo?`)) return;

            try {
                const response = await fetch(
                    `${VISION_SERVER_URL}/api/faces/${encodeURIComponent(myFaceName)}/photo/${encodeURIComponent(filename)}`,
                    {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: clerkUser.id })
                    }
                );

                if (response.ok) {
                    registerStatus.textContent = '‚úÖ Photo deleted';
                    registerStatus.style.color = 'var(--green)';
                    await loadCommunityList();
                    updateMyFaceSection();
                } else {
                    const result = await response.json();
                    throw new Error(result.error || 'Delete failed');
                }
            } catch (error) {
                console.error('Delete error:', error);
                registerStatus.textContent = `‚ùå ${error.message}`;
                registerStatus.style.color = 'var(--red)';
            }
        };

        // Capture from webcam
        captureBtn.addEventListener('click', async () => {
            if (!clerkUser) {
                registerStatus.textContent = '‚ö†Ô∏è Please login first';
                registerStatus.style.color = 'var(--orange)';
                return;
            }

            const name = registerName.value.trim();
            if (!name) {
                registerStatus.textContent = '‚ö†Ô∏è Please enter your name first';
                registerStatus.style.color = 'var(--orange)';
                return;
            }

            if (!cameraStream) {
                registerStatus.textContent = '‚ö†Ô∏è Turn on the camera first (click camera button)';
                registerStatus.style.color = 'var(--orange)';
                return;
            }

            // Check current photo count for this user
            const existingCount = facesData[name] ? facesData[name].photo_count : 0;
            if (existingCount + pendingPhotos.length >= MAX_PHOTOS_PER_USER) {
                registerStatus.textContent = `‚ö†Ô∏è Max ${MAX_PHOTOS_PER_USER} photos per person`;
                registerStatus.style.color = 'var(--orange)';
                return;
            }

            const frame = captureFrame();
            if (frame) {
                pendingPhotos.push(frame);
                updatePhotoPreview();
                await savePhoto(name, frame);
            }
        });

        // Upload file
        uploadBtn.addEventListener('click', () => {
            if (!clerkUser) {
                registerStatus.textContent = '‚ö†Ô∏è Please login first';
                registerStatus.style.color = 'var(--orange)';
                return;
            }

            const name = registerName.value.trim();
            if (!name) {
                registerStatus.textContent = '‚ö†Ô∏è Please enter your name first';
                registerStatus.style.color = 'var(--orange)';
                return;
            }
            fileUpload.click();
        });

        fileUpload.addEventListener('change', async (e) => {
            if (!clerkUser) return;

            const name = registerName.value.trim();
            const files = Array.from(e.target.files);

            // Check limits
            const existingCount = facesData[name] ? facesData[name].photo_count : 0;
            const availableSlots = MAX_PHOTOS_PER_USER - existingCount - pendingPhotos.length;

            if (availableSlots <= 0) {
                registerStatus.textContent = `‚ö†Ô∏è Max ${MAX_PHOTOS_PER_USER} photos per person`;
                registerStatus.style.color = 'var(--orange)';
                return;
            }

            const filesToProcess = files.slice(0, availableSlots);

            for (const file of filesToProcess) {
                try {
                    const base64 = await fileToBase64(file);
                    pendingPhotos.push(base64);
                    updatePhotoPreview();
                    await savePhoto(name, base64);
                } catch (error) {
                    console.error('Upload error:', error);
                    registerStatus.textContent = '‚ùå Upload failed';
                    registerStatus.style.color = 'var(--red)';
                }
            }

            fileUpload.value = ''; // Reset
        });

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function updatePhotoPreview() {
            photoPreview.innerHTML = pendingPhotos.map((photo, i) =>
                `<img src="${photo}" alt="Photo ${i + 1}" />`
            ).join('');
        }

        async function savePhoto(name, imageData) {
            try {
                registerStatus.textContent = '‚è≥ Saving...';
                registerStatus.style.color = 'var(--cyan)';

                const response = await fetch(`${VISION_SERVER_URL}/api/faces/${encodeURIComponent(name)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: imageData,
                        user_id: clerkUser ? clerkUser.id : null
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    registerStatus.textContent = `‚úÖ Photo saved for ${name}!`;
                    registerStatus.style.color = 'var(--green)';
                    await loadCommunityList(); // Refresh list
                    updateMyFaceSection();
                    pendingPhotos = [];
                    photoPreview.innerHTML = '';
                } else {
                    throw new Error(result.error || 'Save failed');
                }
            } catch (error) {
                console.error('Save error:', error);
                registerStatus.textContent = `‚ùå ${error.message}`;
                registerStatus.style.color = 'var(--red)';
            }
        }

        // Clear preview when name changes
        registerName.addEventListener('input', () => {
            pendingPhotos = [];
            photoPreview.innerHTML = '';
            registerStatus.textContent = '';
        });

        // Refresh community list when face is identified (to show confidence)
        const originalIdentifyFace = identifyFace;
        window.identifyFaceWithRefresh = async function() {
            await originalIdentifyFace();
            if (communityContent.classList.contains('open')) {
                loadCommunityList();
            }
        };

        // Load community list on page load
        loadCommunityList();
    </script>
</body>
</html>
